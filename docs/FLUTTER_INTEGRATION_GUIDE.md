# Flutter Rust Bridge Integration Guide for KhodPay Wallet

This document provides a step-by-step guide to integrate the KhodPay Rust wallet library with Flutter using Flutter Rust Bridge (FRB) v2.

## ğŸ“‹ Prerequisites

- Rust toolchain (version 1.81+)
- Flutter SDK
- `flutter_rust_bridge_codegen` CLI tool
- Basic understanding of both Rust and Flutter/Dart

### Installing flutter_rust_bridge_codegen

```bash
cargo install flutter_rust_bridge_codegen
```

## ğŸ—ï¸ Project Structure

Your project structure after integration will look like this:

```
khodpay-wallet/
â”œâ”€â”€ Cargo.toml                    # Workspace root
â”œâ”€â”€ crates/
â”‚   â”œâ”€â”€ bip32/                    # Your existing BIP32 crate
â”‚   â”œâ”€â”€ bip39/                    # Your existing BIP39 crate
â”‚   â””â”€â”€ flutter_bridge/           # New bridge crate (to be created)
â”‚       â”œâ”€â”€ Cargo.toml
â”‚       â”œâ”€â”€ src/
â”‚       â”‚   â”œâ”€â”€ lib.rs
â”‚       â”‚   â”œâ”€â”€ bridge.rs         # Bridge definitions
â”‚       â”‚   â””â”€â”€ bridge_generated.rs  # Auto-generated by FRB
â”œâ”€â”€ build/                        # Build outputs directory
â”‚   â”œâ”€â”€ dart/                     # Generated Dart bindings
â”‚   â”‚   â””â”€â”€ bridge_generated.dart
â”‚   â””â”€â”€ rust/                     # Compiled libraries
â”‚       â”œâ”€â”€ debug/
â”‚       â””â”€â”€ release/
â””â”€â”€ flutter/                      # Your Flutter app (if in same repo)
```

---

## ğŸš€ Step-by-Step Implementation

### Step 1: Update Workspace Configuration

First, add the new bridge crate to your workspace.

**File:** `Cargo.toml` (root)

```toml
[workspace]
members = ["crates/bip39", "crates/bip32", "crates/flutter_bridge"]
resolver = "2"

# ... rest of your workspace config
```

---

### Step 2: Create the Flutter Bridge Crate

Create a new crate specifically for the Flutter bridge:

```bash
# From project root
mkdir -p crates/flutter_bridge/src
```

**File:** `crates/flutter_bridge/Cargo.toml`

```toml
[package]
name = "khodpay-flutter-bridge"
version = "0.1.0"
edition = "2021"
rust-version = "1.81"

[lib]
crate-type = ["cdylib", "staticlib"]  # For Flutter FFI
name = "khodpay_flutter_bridge"

[dependencies]
# Flutter Rust Bridge
flutter_rust_bridge = "2"

# Your local crates
khodpay-bip32 = { version = "0.2.0", path = "../bip32" }
khodpay-bip39 = { version = "0.2.0", path = "../bip39" }

# Optional: For serializable structs
serde = { version = "1", features = ["derive"] }

# Required dependencies from your crates
anyhow = "1.0"

[profile.release]
opt-level = 3
lto = true
codegen-units = 1
strip = true
```

---

### Step 3: Create Bridge Definitions

**File:** `crates/flutter_bridge/src/bridge.rs`

This file contains your API that Flutter will call. It includes **both struct wrappers (for OOP API) and utility functions (for convenience)**.

```rust
use flutter_rust_bridge::frb;
use khodpay_bip32::{
    ExtendedPrivateKey as RustExtendedPrivateKey,
    ExtendedPublicKey as RustExtendedPublicKey,
    Network, DerivationPath, ChildNumber,
};
use khodpay_bip39::{Mnemonic as RustMnemonic, WordCount, Language};
use std::str::FromStr;

// =============================================================================
// PART 1: ENUMS AND DATA TYPES
// =============================================================================

/// Network type for the wallet
#[frb]
#[derive(Debug, Clone, Copy)]
pub enum NetworkType {
    BitcoinMainnet,
    BitcoinTestnet,
}

impl From<NetworkType> for Network {
    fn from(nt: NetworkType) -> Self {
        match nt {
            NetworkType::BitcoinMainnet => Network::BitcoinMainnet,
            NetworkType::BitcoinTestnet => Network::BitcoinTestnet,
        }
    }
}

impl From<Network> for NetworkType {
    fn from(n: Network) -> Self {
        match n {
            Network::BitcoinMainnet => NetworkType::BitcoinMainnet,
            Network::BitcoinTestnet => NetworkType::BitcoinTestnet,
        }
    }
}

/// Result type for wallet operations (used by utility functions)
#[frb]
#[derive(Debug, Clone)]
pub struct WalletResult {
    pub success: bool,
    pub message: String,
    pub data: Option<String>,
}

// =============================================================================
// PART 2: STRUCT WRAPPERS (Object-Oriented API)
// =============================================================================

/// Flutter wrapper for Mnemonic - provides OOP interface
#[frb]
pub struct Mnemonic {
    inner: RustMnemonic,
}

#[frb]
impl Mnemonic {
    /// Generate a new mnemonic with specified word count
    #[frb]
    pub fn generate(word_count: u32) -> Result<Self, String> {
        let count = match word_count {
            12 => WordCount::Twelve,
            15 => WordCount::Fifteen,
            18 => WordCount::Eighteen,
            21 => WordCount::TwentyOne,
            24 => WordCount::TwentyFour,
            _ => return Err("Invalid word count. Use 12, 15, 18, 21, or 24".to_string()),
        };

        let mnemonic = RustMnemonic::generate(count, Language::English)
            .map_err(|e| format!("Failed to generate mnemonic: {}", e))?;
        
        Ok(Self { inner: mnemonic })
    }

    /// Parse mnemonic from phrase string
    #[frb]
    pub fn from_phrase(phrase: String) -> Result<Self, String> {
        let mnemonic = RustMnemonic::from_phrase(&phrase, Language::English)
            .map_err(|e| format!("Invalid mnemonic: {}", e))?;
        Ok(Self { inner: mnemonic })
    }

    /// Convert mnemonic to string phrase
    #[frb]
    pub fn to_phrase(&self) -> String {
        self.inner.to_string()
    }

    /// Get the word count
    #[frb]
    pub fn word_count(&self) -> u32 {
        self.inner.to_string().split_whitespace().count() as u32
    }

    /// Validate that this mnemonic is valid (always true for constructed mnemonics)
    #[frb]
    pub fn is_valid(&self) -> bool {
        true
    }
}

/// Flutter wrapper for ExtendedPrivateKey - provides OOP interface
#[frb]
pub struct ExtendedPrivateKey {
    inner: RustExtendedPrivateKey,
}

#[frb]
impl ExtendedPrivateKey {
    /// Create master key from seed bytes
    #[frb]
    pub fn from_seed(seed: Vec<u8>, network: NetworkType) -> Result<Self, String> {
        let key = RustExtendedPrivateKey::from_seed(&seed, network.into())
            .map_err(|e| format!("Failed to create key from seed: {}", e))?;
        Ok(Self { inner: key })
    }

    /// Create master key from mnemonic
    #[frb]
    pub fn from_mnemonic(
        mnemonic: &Mnemonic,
        passphrase: Option<String>,
        network: NetworkType,
    ) -> Result<Self, String> {
        let key = RustExtendedPrivateKey::from_mnemonic(
            &mnemonic.inner,
            passphrase.as_deref(),
            network.into(),
        )
        .map_err(|e| format!("Failed to create key from mnemonic: {}", e))?;
        Ok(Self { inner: key })
    }

    /// Parse from string (xprv... format)
    #[frb]
    pub fn from_string(s: String) -> Result<Self, String> {
        let key = RustExtendedPrivateKey::from_str(&s)
            .map_err(|e| format!("Invalid extended private key: {}", e))?;
        Ok(Self { inner: key })
    }

    /// Serialize to string (xprv... format)
    #[frb]
    pub fn to_string(&self) -> String {
        self.inner.to_string()
    }

    /// Get the network this key belongs to
    #[frb]
    pub fn network(&self) -> NetworkType {
        self.inner.network().into()
    }

    /// Get the depth in derivation tree (0 = master, 1 = level-1 child, etc.)
    #[frb]
    pub fn depth(&self) -> u8 {
        self.inner.depth()
    }

    /// Get the parent fingerprint (4 bytes)
    #[frb]
    pub fn parent_fingerprint(&self) -> Vec<u8> {
        self.inner.parent_fingerprint().to_vec()
    }

    /// Get this key's fingerprint (4 bytes)
    #[frb]
    pub fn fingerprint(&self) -> Vec<u8> {
        self.inner.fingerprint().to_vec()
    }

    /// Get the child number index
    #[frb]
    pub fn child_number_index(&self) -> u32 {
        match self.inner.child_number() {
            ChildNumber::Normal(n) | ChildNumber::Hardened(n) => n,
        }
    }

    /// Check if this is a hardened key
    #[frb]
    pub fn is_hardened(&self) -> bool {
        matches!(self.inner.child_number(), ChildNumber::Hardened(_))
    }

    /// Derive a single child key
    #[frb]
    pub fn derive_child(&self, index: u32, hardened: bool) -> Result<Self, String> {
        let child_num = if hardened {
            ChildNumber::Hardened(index)
        } else {
            ChildNumber::Normal(index)
        };

        let child = self.inner.derive_child(child_num)
            .map_err(|e| format!("Failed to derive child: {}", e))?;
        
        Ok(Self { inner: child })
    }

    /// Derive using a path string (e.g., "m/44'/0'/0'/0/0")
    #[frb]
    pub fn derive_path(&self, path: String) -> Result<Self, String> {
        let derivation_path = DerivationPath::from_str(&path)
            .map_err(|e| format!("Invalid derivation path: {}", e))?;
        
        let derived = self.inner.derive_path(&derivation_path)
            .map_err(|e| format!("Failed to derive path: {}", e))?;
        
        Ok(Self { inner: derived })
    }

    /// Convert to extended public key
    #[frb]
    pub fn to_extended_public_key(&self) -> ExtendedPublicKey {
        ExtendedPublicKey {
            inner: self.inner.to_extended_public_key(),
        }
    }
}

/// Flutter wrapper for ExtendedPublicKey - provides OOP interface
#[frb]
pub struct ExtendedPublicKey {
    inner: RustExtendedPublicKey,
}

#[frb]
impl ExtendedPublicKey {
    /// Parse from string (xpub... format)
    #[frb]
    pub fn from_string(s: String) -> Result<Self, String> {
        let key = RustExtendedPublicKey::from_str(&s)
            .map_err(|e| format!("Invalid extended public key: {}", e))?;
        Ok(Self { inner: key })
    }

    /// Serialize to string (xpub... format)
    #[frb]
    pub fn to_string(&self) -> String {
        self.inner.to_string()
    }

    /// Get the network this key belongs to
    #[frb]
    pub fn network(&self) -> NetworkType {
        self.inner.network().into()
    }

    /// Get the depth in derivation tree
    #[frb]
    pub fn depth(&self) -> u8 {
        self.inner.depth()
    }

    /// Get the parent fingerprint (4 bytes)
    #[frb]
    pub fn parent_fingerprint(&self) -> Vec<u8> {
        self.inner.parent_fingerprint().to_vec()
    }

    /// Get this key's fingerprint (4 bytes)
    #[frb]
    pub fn fingerprint(&self) -> Vec<u8> {
        self.inner.fingerprint().to_vec()
    }

    /// Get the child number index
    #[frb]
    pub fn child_number_index(&self) -> u32 {
        match self.inner.child_number() {
            ChildNumber::Normal(n) | ChildNumber::Hardened(n) => n,
        }
    }

    /// Check if this is a hardened key (public keys can only have non-hardened children)
    #[frb]
    pub fn is_hardened(&self) -> bool {
        matches!(self.inner.child_number(), ChildNumber::Hardened(_))
    }

    /// Derive a child public key (non-hardened only)
    #[frb]
    pub fn derive_child(&self, index: u32) -> Result<Self, String> {
        let child = self.inner.derive_child(ChildNumber::Normal(index))
            .map_err(|e| format!("Failed to derive child: {}", e))?;
        Ok(Self { inner: child })
    }

    /// Derive using a path string (only non-hardened paths allowed)
    #[frb]
    pub fn derive_path(&self, path: String) -> Result<Self, String> {
        let derivation_path = DerivationPath::from_str(&path)
            .map_err(|e| format!("Invalid derivation path: {}", e))?;
        
        let derived = self.inner.derive_path(&derivation_path)
            .map_err(|e| format!("Failed to derive path (hardened derivation not allowed): {}", e))?;
        
        Ok(Self { inner: derived })
    }
}

// =============================================================================
// PART 3: UTILITY FUNCTIONS (Convenience API)
// =============================================================================

/// Generate a new BIP39 mnemonic phrase (returns string)
#[frb]
pub fn generate_mnemonic(word_count: u32) -> Result<String, String> {
    let count = match word_count {
        12 => WordCount::Twelve,
        15 => WordCount::Fifteen,
        18 => WordCount::Eighteen,
        21 => WordCount::TwentyOne,
        24 => WordCount::TwentyFour,
        _ => return Err("Invalid word count. Use 12, 15, 18, 21, or 24".to_string()),
    };

    let mnemonic = RustMnemonic::generate(count, Language::English)
        .map_err(|e| format!("Failed to generate mnemonic: {}", e))?;

    Ok(mnemonic.to_string())
}

/// Validate a mnemonic phrase
#[frb]
pub fn validate_mnemonic(phrase: String) -> bool {
    RustMnemonic::from_phrase(&phrase, Language::English).is_ok()
}

/// Create a master extended private key from a mnemonic string
#[frb]
pub fn create_master_key(
    mnemonic: String,
    passphrase: Option<String>,
    network: NetworkType,
) -> Result<String, String> {
    let mnemonic = RustMnemonic::from_phrase(&mnemonic, Language::English)
        .map_err(|e| format!("Invalid mnemonic: {}", e))?;

    let master_key = RustExtendedPrivateKey::from_mnemonic(
        &mnemonic,
        passphrase.as_deref(),
        network.into(),
    )
    .map_err(|e| format!("Failed to create master key: {}", e))?;

    Ok(master_key.to_string())
}

/// Derive a child key from an extended private key using a derivation path
#[frb]
pub fn derive_key(
    extended_key: String,
    derivation_path: String,
) -> Result<String, String> {
    let master_key = RustExtendedPrivateKey::from_str(&extended_key)
        .map_err(|e| format!("Invalid extended key: {}", e))?;

    let path = DerivationPath::from_str(&derivation_path)
        .map_err(|e| format!("Invalid derivation path: {}", e))?;

    let derived_key = master_key
        .derive_path(&path)
        .map_err(|e| format!("Failed to derive key: {}", e))?;

    Ok(derived_key.to_string())
}

/// Get the public key from an extended private key string
#[frb]
pub fn get_public_key(extended_private_key: String) -> Result<String, String> {
    let private_key = RustExtendedPrivateKey::from_str(&extended_private_key)
        .map_err(|e| format!("Invalid extended private key: {}", e))?;

    let public_key = private_key.to_extended_public_key();
    Ok(public_key.to_string())
}

/// Get address from an extended private key at specific index
#[frb]
pub fn get_address(
    extended_private_key: String,
    address_index: u32,
) -> Result<String, String> {
    let private_key = RustExtendedPrivateKey::from_str(&extended_private_key)
        .map_err(|e| format!("Invalid extended private key: {}", e))?;

    // Derive the address key (m/0/address_index)
    let path = DerivationPath::from_str(&format!("m/0/{}", address_index))
        .map_err(|e| format!("Invalid path: {}", e))?;

    let address_key = private_key
        .derive_path(&path)
        .map_err(|e| format!("Failed to derive address: {}", e))?;

    let public_key = address_key.to_extended_public_key();
    
    // Return the extended public key (you may want to convert to Bitcoin address format)
    Ok(public_key.to_string())
}

/// Create a complete BIP44 wallet and return the account key
#[frb]
pub fn create_bip44_wallet(
    mnemonic: String,
    passphrase: Option<String>,
    account_index: u32,
    network: NetworkType,
) -> Result<WalletResult, String> {
    let mnemonic = RustMnemonic::from_phrase(&mnemonic, Language::English)
        .map_err(|e| format!("Invalid mnemonic: {}", e))?;

    let master_key = RustExtendedPrivateKey::from_mnemonic(
        &mnemonic,
        passphrase.as_deref(),
        network.into(),
    )
    .map_err(|e| format!("Failed to create master key: {}", e))?;

    // BIP44 path: m/44'/0'/account_index'
    let coin_type = match network {
        NetworkType::BitcoinMainnet => 0,
        NetworkType::BitcoinTestnet => 1,
    };
    
    let path_str = format!("m/44'/{}'/{}'", coin_type, account_index);
    let path = DerivationPath::from_str(&path_str)
        .map_err(|e| format!("Invalid derivation path: {}", e))?;

    let account_key = master_key
        .derive_path(&path)
        .map_err(|e| format!("Failed to derive account key: {}", e))?;

    Ok(WalletResult {
        success: true,
        message: format!("Wallet created with path: {}", path_str),
        data: Some(account_key.to_string()),
    })
}

// =============================================================================
// PART 4: SIMPLE UTILITY FUNCTIONS
// =============================================================================

/// Simple health check function
#[frb]
pub fn health_check() -> String {
    "KhodPay Wallet Bridge is working!".to_string()
}

/// Add two numbers (example from the article)
#[frb]
pub fn add(a: i32, b: i32) -> i32 {
    a + b
}
```

---

### Step 4: Create Library Entry Point

**File:** `crates/flutter_bridge/src/lib.rs`

```rust
//! Flutter Rust Bridge for KhodPay Wallet
//!
//! This crate provides Flutter bindings for the KhodPay wallet functionality.

// Include the bridge module
mod bridge;

// Include the generated bridge code
// This file will be created by flutter_rust_bridge_codegen
mod bridge_generated;

// Re-export bridge functions
pub use bridge::*;
```

---

### Step 5: Configure Build Output Directory

Create a configuration file to specify where build outputs should go.

**File:** `.cargo/config.toml` (create if doesn't exist)

```toml
[build]
# All build artifacts go to the build/rust directory
target-dir = "build/rust"
```

---

### Step 6: Run the FRB Code Generator

Create a build script to automate code generation:

**File:** `scripts/generate_bridge.sh`

```bash
#!/bin/bash
set -e

# Colors for output
GREEN='\033[0;32m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

echo -e "${BLUE}ğŸ”¨ Generating Flutter Rust Bridge bindings...${NC}"

# Create build/dart directory if it doesn't exist
mkdir -p build/dart

# Run the code generator
flutter_rust_bridge_codegen \
  --rust-input crates/flutter_bridge/src/bridge.rs \
  --dart-output build/dart/bridge_generated.dart \
  --rust-output crates/flutter_bridge/src/bridge_generated.rs

echo -e "${GREEN}âœ… Bridge code generation completed!${NC}"
echo -e "${BLUE}ğŸ“ Dart bindings: build/dart/bridge_generated.dart${NC}"
echo -e "${BLUE}ğŸ“ Rust bindings: crates/flutter_bridge/src/bridge_generated.rs${NC}"
```

Make it executable:

```bash
chmod +x scripts/generate_bridge.sh
```

**Run the generator:**

```bash
./scripts/generate_bridge.sh
```

---

### Step 7: Build the Rust Library

Create a build script for different platforms:

**File:** `scripts/build_rust.sh`

```bash
#!/bin/bash
set -e

# Colors
GREEN='\033[0;32m'
BLUE='\033[0;34m'
YELLOW='\033[1;33m'
NC='\033[0m'

BUILD_MODE=${1:-release}  # Default to release build
PLATFORM=${2:-current}     # Default to current platform

echo -e "${BLUE}ğŸ”¨ Building Rust library for Flutter...${NC}"
echo -e "${YELLOW}Mode: $BUILD_MODE${NC}"
echo -e "${YELLOW}Platform: $PLATFORM${NC}"

cd crates/flutter_bridge

if [ "$BUILD_MODE" = "debug" ]; then
    if [ "$PLATFORM" = "android" ]; then
        # Android ARM64
        cargo build --target aarch64-linux-android
        # Android ARMv7
        cargo build --target armv7-linux-androideabi
    elif [ "$PLATFORM" = "ios" ]; then
        # iOS ARM64
        cargo build --target aarch64-apple-ios
    else
        # Current platform (for desktop/development)
        cargo build
    fi
else
    if [ "$PLATFORM" = "android" ]; then
        cargo build --release --target aarch64-linux-android
        cargo build --release --target armv7-linux-androideabi
    elif [ "$PLATFORM" = "ios" ]; then
        cargo build --release --target aarch64-apple-ios
    else
        cargo build --release
    fi
fi

cd ../..

echo -e "${GREEN}âœ… Build completed!${NC}"
echo -e "${BLUE}ğŸ“ Build artifacts are in: build/rust/$BUILD_MODE${NC}"
```

Make it executable and run:

```bash
chmod +x scripts/build_rust.sh
./scripts/build_rust.sh release
```

---

### Step 8: Integration with Flutter

Once the Rust library is built, integrate it with your Flutter app:

**File:** `flutter/pubspec.yaml` (in your Flutter project)

```yaml
dependencies:
  flutter:
    sdk: flutter
  flutter_rust_bridge: ^2.0.0
  ffi: ^2.0.0
```

**File:** `flutter/lib/rust_bridge.dart`

```dart
import 'dart:ffi';
import 'dart:io';
import 'package:flutter_rust_bridge/flutter_rust_bridge.dart';

// Import the generated bindings
import '../../../build/dart/bridge_generated.dart';

// Platform-specific library loading
DynamicLibrary _loadLibrary() {
  if (Platform.isAndroid) {
    return DynamicLibrary.open('libkhodpay_flutter_bridge.so');
  } else if (Platform.isIOS) {
    return DynamicLibrary.process();
  } else if (Platform.isMacOS) {
    return DynamicLibrary.open('libkhodpay_flutter_bridge.dylib');
  } else if (Platform.isWindows) {
    return DynamicLibrary.open('khodpay_flutter_bridge.dll');
  } else if (Platform.isLinux) {
    return DynamicLibrary.open('libkhodpay_flutter_bridge.so');
  }
  throw UnsupportedError('Platform not supported');
}

// Initialize the bridge - this is your API instance
final api = RustImpl(_loadLibrary());

// Convenience wrapper class (optional but recommended)
class KhodPayWallet {
  // ==========================================================================
  // APPROACH 1: Object-Oriented API (Using Struct Wrappers)
  // ==========================================================================
  
  /// Generate a mnemonic and return as object
  static Future<Mnemonic> generateMnemonicObject({int wordCount = 12}) async {
    return await Mnemonic.generate(wordCount: wordCount);
  }
  
  /// Create wallet using OOP approach
  static Future<ExtendedPrivateKey> createWalletFromMnemonic({
    required Mnemonic mnemonic,
    String? passphrase,
    required NetworkType network,
  }) async {
    return await ExtendedPrivateKey.fromMnemonic(
      mnemonic: mnemonic,
      passphrase: passphrase,
      network: network,
    );
  }
  
  // ==========================================================================
  // APPROACH 2: Utility Functions (Using Strings)
  // ==========================================================================
  
  /// Generate mnemonic and return as string
  static Future<String> generateMnemonicString({int wordCount = 12}) async {
    return await api.generateMnemonic(wordCount: wordCount);
  }

  /// Validate a mnemonic phrase
  static Future<bool> validateMnemonic(String phrase) async {
    return await api.validateMnemonic(phrase: phrase);
  }

  /// Create master key from mnemonic string
  static Future<String> createMasterKey({
    required String mnemonic,
    String? passphrase,
    required NetworkType network,
  }) async {
    return await api.createMasterKey(
      mnemonic: mnemonic,
      passphrase: passphrase,
      network: network,
    );
  }
  
  /// Derive key using path string
  static Future<String> deriveKey({
    required String extendedKey,
    required String path,
  }) async {
    return await api.deriveKey(
      extendedKey: extendedKey,
      derivationPath: path,
    );
  }

  /// Health check
  static Future<String> healthCheck() async {
    return await api.healthCheck();
  }
}
```

**Usage Examples:**

```dart
// Example 1: Object-Oriented Approach (Recommended)
void exampleOOP() async {
  // Generate mnemonic as object
  final mnemonic = await Mnemonic.generate(wordCount: 12);
  print('Mnemonic: ${await mnemonic.toPhrase()}');
  print('Word count: ${await mnemonic.wordCount()}');
  
  // Create master key from mnemonic object
  final masterKey = await ExtendedPrivateKey.fromMnemonic(
    mnemonic: mnemonic,
    passphrase: null,
    network: NetworkType.BitcoinMainnet,
  );
  
  // Access properties directly
  print('Master key depth: ${await masterKey.depth()}'); // 0
  print('Network: ${await masterKey.network()}');
  print('Fingerprint: ${await masterKey.fingerprint()}');
  
  // Derive child keys - method chaining style!
  final account = await masterKey.deriveChild(index: 44, hardened: true);
  final coin = await account.deriveChild(index: 0, hardened: true);
  final wallet = await coin.deriveChild(index: 0, hardened: true);
  
  print('Account depth: ${await wallet.depth()}'); // 3
  
  // Or use path derivation
  final derived = await masterKey.derivePath(path: "m/44'/0'/0'");
  print('Derived xprv: ${await derived.toExtendedString()}');
  
  // Get public key
  final pubKey = await masterKey.toExtendedPublicKey();
  print('Public key: ${await pubKey.toExtendedString()}');
  
  // Derive address from public key (non-hardened only)
  final addressPubKey = await pubKey.deriveChild(index: 0);
  print('Address pub key: ${await addressPubKey.toExtendedString()}');
}

// Example 2: Utility Function Approach (Simple but less type-safe)
void exampleUtilityFunctions() async {
  // Generate mnemonic as string
  final mnemonicStr = await KhodPayWallet.generateMnemonicString(wordCount: 12);
  print('Mnemonic: $mnemonicStr');
  
  // Validate it
  final isValid = await KhodPayWallet.validateMnemonic(mnemonicStr);
  print('Valid: $isValid');
  
  // Create master key (returns string)
  final masterKeyStr = await KhodPayWallet.createMasterKey(
    mnemonic: mnemonicStr,
    passphrase: null,
    network: NetworkType.BitcoinMainnet,
  );
  print('Master key: $masterKeyStr');
  
  // Derive child key
  final derivedStr = await KhodPayWallet.deriveKey(
    extendedKey: masterKeyStr,
    path: "m/44'/0'/0'",
  );
  print('Derived key: $derivedStr');
  
  // Get public key
  final pubKeyStr = await api.getPublicKey(extendedPrivateKey: masterKeyStr);
  print('Public key: $pubKeyStr');
}

// Example 3: Mixed Approach (Best of both worlds)
void exampleMixed() async {
  // Start with OOP for type safety
  final mnemonic = await Mnemonic.generate(wordCount: 12);
  final masterKey = await ExtendedPrivateKey.fromMnemonic(
    mnemonic: mnemonic,
    passphrase: null,
    network: NetworkType.BitcoinMainnet,
  );
  
  // Serialize to string for storage
  final masterKeyStr = await masterKey.toExtendedString();
  // ... save to secure storage ...
  
  // Later: deserialize back to object
  final loadedKey = await ExtendedPrivateKey.fromString(masterKeyStr);
  final depth = await loadedKey.depth();
  print('Loaded key depth: $depth');
}
```

---

### Step 9: Testing the Integration

**File:** `flutter/test/wallet_test.dart`

```dart
import 'package:flutter_test/flutter_test.dart';
import 'package:your_app/rust_bridge.dart';

void main() {
  group('Basic Tests', () {
    test('Health check', () async {
      final result = await KhodPayWallet.healthCheck();
      expect(result, contains('working'));
    });

    test('Add function', () async {
      final result = await api.add(a: 5, b: 3);
      expect(result, 8);
    });
  });

  group('Utility Function API Tests', () {
    test('Generate mnemonic string', () async {
      final mnemonic = await KhodPayWallet.generateMnemonicString(wordCount: 12);
      expect(mnemonic.split(' ').length, 12);
    });

    test('Validate mnemonic', () async {
      final mnemonic = await KhodPayWallet.generateMnemonicString(wordCount: 12);
      final isValid = await KhodPayWallet.validateMnemonic(mnemonic);
      expect(isValid, true);
    });

    test('Create master key from string', () async {
      final mnemonic = await KhodPayWallet.generateMnemonicString(wordCount: 12);
      final masterKey = await KhodPayWallet.createMasterKey(
        mnemonic: mnemonic,
        passphrase: null,
        network: NetworkType.BitcoinMainnet,
      );
      expect(masterKey, startsWith('xprv'));
    });

    test('Derive key using path', () async {
      final mnemonic = await KhodPayWallet.generateMnemonicString(wordCount: 12);
      final masterKey = await KhodPayWallet.createMasterKey(
        mnemonic: mnemonic,
        passphrase: null,
        network: NetworkType.BitcoinMainnet,
      );
      final derived = await KhodPayWallet.deriveKey(
        extendedKey: masterKey,
        path: "m/44'/0'/0'",
      );
      expect(derived, startsWith('xprv'));
    });
  });

  group('Object-Oriented API Tests', () {
    test('Generate mnemonic object', () async {
      final mnemonic = await Mnemonic.generate(wordCount: 12);
      final phrase = await mnemonic.toPhrase();
      expect(phrase.split(' ').length, 12);
      
      final wordCount = await mnemonic.wordCount();
      expect(wordCount, 12);
      
      final isValid = await mnemonic.isValid();
      expect(isValid, true);
    });

    test('Create master key from mnemonic object', () async {
      final mnemonic = await Mnemonic.generate(wordCount: 12);
      final masterKey = await ExtendedPrivateKey.fromMnemonic(
        mnemonic: mnemonic,
        passphrase: null,
        network: NetworkType.BitcoinMainnet,
      );
      
      final depth = await masterKey.depth();
      expect(depth, 0); // Master key has depth 0
      
      final network = await masterKey.network();
      expect(network, NetworkType.BitcoinMainnet);
      
      final xprv = await masterKey.toExtendedString();
      expect(xprv, startsWith('xprv'));
    });

    test('Derive child keys', () async {
      final mnemonic = await Mnemonic.generate(wordCount: 12);
      final masterKey = await ExtendedPrivateKey.fromMnemonic(
        mnemonic: mnemonic,
        passphrase: null,
        network: NetworkType.BitcoinMainnet,
      );
      
      // Derive hardened child
      final child = await masterKey.deriveChild(index: 0, hardened: true);
      final childDepth = await child.depth();
      expect(childDepth, 1);
      
      final isHardened = await child.isHardened();
      expect(isHardened, true);
    });

    test('Derive using path', () async {
      final mnemonic = await Mnemonic.generate(wordCount: 12);
      final masterKey = await ExtendedPrivateKey.fromMnemonic(
        mnemonic: mnemonic,
        passphrase: null,
        network: NetworkType.BitcoinMainnet,
      );
      
      final derived = await masterKey.derivePath(path: "m/44'/0'/0'");
      final depth = await derived.depth();
      expect(depth, 3); // m/44'/0'/0' is depth 3
    });

    test('Convert to public key', () async {
      final mnemonic = await Mnemonic.generate(wordCount: 12);
      final masterKey = await ExtendedPrivateKey.fromMnemonic(
        mnemonic: mnemonic,
        passphrase: null,
        network: NetworkType.BitcoinMainnet,
      );
      
      final pubKey = await masterKey.toExtendedPublicKey();
      final xpub = await pubKey.toExtendedString();
      expect(xpub, startsWith('xpub'));
      
      final pubDepth = await pubKey.depth();
      expect(pubDepth, 0);
    });

    test('Serialize and deserialize', () async {
      final mnemonic = await Mnemonic.generate(wordCount: 12);
      final masterKey = await ExtendedPrivateKey.fromMnemonic(
        mnemonic: mnemonic,
        passphrase: null,
        network: NetworkType.BitcoinMainnet,
      );
      
      // Serialize to string
      final xprv = await masterKey.toExtendedString();
      
      // Deserialize back
      final loadedKey = await ExtendedPrivateKey.fromString(xprv);
      final loadedXprv = await loadedKey.toExtendedString();
      
      expect(loadedXprv, xprv);
    });
  });

  group('Integration Tests', () {
    test('Complete BIP44 wallet creation', () async {
      final mnemonicStr = await KhodPayWallet.generateMnemonicString(wordCount: 12);
      final result = await api.createBip44Wallet(
        mnemonic: mnemonicStr,
        passphrase: null,
        accountIndex: 0,
        network: NetworkType.BitcoinMainnet,
      );
      
      expect(result.success, true);
      expect(result.message, contains("m/44'/0'/0'"));
      expect(result.data, isNotNull);
      expect(result.data!, startsWith('xprv'));
    });
  });
}
```

---

## ğŸ”„ Development Workflow

### Complete Build Process

Create a master build script:

**File:** `scripts/build_all.sh`

```bash
#!/bin/bash
set -e

echo "ğŸš€ Starting complete build process..."

# Step 1: Generate bridge code
echo "ğŸ“ Step 1: Generating bridge code..."
./scripts/generate_bridge.sh

# Step 2: Build Rust library
echo "ğŸ”¨ Step 2: Building Rust library..."
./scripts/build_rust.sh release

# Step 3: Copy libraries to Flutter
echo "ğŸ“¦ Step 3: Copying libraries to Flutter..."
mkdir -p flutter/lib/native
cp build/rust/release/libkhodpay_flutter_bridge.* flutter/lib/native/ 2>/dev/null || true

echo "âœ… Build process completed!"
echo "ğŸ“± You can now run your Flutter app"
```

---

## ğŸ“± Platform-Specific Notes

### Android
- Ensure you have Android NDK installed
- Add targets: `rustup target add aarch64-linux-android armv7-linux-androideabi`

### iOS
- Xcode and iOS SDK required
- Add target: `rustup target add aarch64-apple-ios`

### macOS
- Native support, no additional setup needed

---

## ğŸ” Troubleshooting

### Common Issues

1. **Code generation fails:**
   - Ensure `flutter_rust_bridge_codegen` is installed
   - Check that all paths in the command are correct

2. **Build fails:**
   - Verify all dependencies are in Cargo.toml
   - Check Rust version compatibility

3. **Flutter can't find library:**
   - Ensure library is copied to correct location
   - Check library name matches in Dart code

---

## ğŸ¨ API Design: Dual Approach Explained

This guide implements **both** Object-Oriented (struct wrappers) and Procedural (utility functions) APIs.

### Why Both Approaches?

#### âœ… **Object-Oriented API (Struct Wrappers)**
**Use when:**
- Building complex wallet features
- Need type safety and IDE autocomplete
- Want to chain operations
- Working with stateful wallet objects

**Advantages:**
- âœ… Full access to all struct methods
- âœ… Type-safe - compiler catches errors
- âœ… Better developer experience
- âœ… Natural Dart/Flutter coding style

**Example:**
```dart
final mnemonic = await Mnemonic.generate(wordCount: 12);
final masterKey = await ExtendedPrivateKey.fromMnemonic(
  mnemonic: mnemonic,
  network: NetworkType.BitcoinMainnet,
);
final depth = await masterKey.depth(); // Type-safe method call
```

#### âœ… **Utility Functions (Procedural)**
**Use when:**
- Quick one-off operations
- Working with serialized data (strings)
- Simple scripts or tools
- Performance-critical paths (less object allocation)

**Advantages:**
- âœ… Simple and straightforward
- âœ… Works with strings (easy to store/transmit)
- âœ… No object lifecycle management
- âœ… Minimal memory overhead

**Example:**
```dart
final mnemonicStr = await generateMnemonic(wordCount: 12);
final keyStr = await createMasterKey(
  mnemonic: mnemonicStr,
  network: NetworkType.BitcoinMainnet,
);
// Work with strings directly
```

### API Comparison Table

| Feature | OOP API | Utility API |
|---------|---------|-------------|
| **Type Safety** | âœ… Strong | âš ï¸ String-based |
| **IDE Support** | âœ… Full autocomplete | âš ï¸ Limited |
| **Method Access** | âœ… All struct methods | âŒ Only exposed functions |
| **Complexity** | Medium | Low |
| **Performance** | Good | Slightly better |
| **Serialization** | Need `.toExtendedString()` | Native strings |
| **Best For** | Production apps | Scripts/tools |

### Recommended Usage Pattern

**For Production Apps:**
1. Use **OOP API** for wallet management and UI
2. Use **Utility Functions** for one-off operations or data validation
3. **Mix both** as needed - they're fully compatible

```dart
// OOP for main wallet logic
final mnemonic = await Mnemonic.generate(wordCount: 12);
final phrase = await mnemonic.toPhrase(); // Get string for storage

// Save to secure storage
await secureStorage.write(key: 'mnemonic', value: phrase);

// Later: Load and validate with utility function
final savedPhrase = await secureStorage.read(key: 'mnemonic');
final isValid = await validateMnemonic(savedPhrase!); // Quick check

// Then convert back to object for use
final loadedMnemonic = await Mnemonic.fromPhrase(savedPhrase!);
final masterKey = await ExtendedPrivateKey.fromMnemonic(...);
```

### What's Available in Each API?

**OOP API Structs:**
- `Mnemonic` - Full mnemonic management
- `ExtendedPrivateKey` - All private key operations & methods
- `ExtendedPublicKey` - All public key operations & methods
- `NetworkType` - Enum for network selection

**Utility Functions:**
- `generateMnemonic()` - Quick mnemonic generation (returns string)
- `validateMnemonic()` - Validate a phrase
- `createMasterKey()` - Create master key from string
- `deriveKey()` - Derive child keys using paths
- `getPublicKey()` - Get public key from private
- `getAddress()` - Get address at index
- `createBip44Wallet()` - Complete BIP44 wallet setup
- `healthCheck()` - System health check
- `add()` - Example math function

---

## ğŸ“š Additional Resources

- [Flutter Rust Bridge Documentation](https://cjycode.com/flutter_rust_bridge/)
- [BIP32 Specification](https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki)
- [BIP39 Specification](https://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki)

---

## ğŸ¯ Next Steps

1. Run `./scripts/generate_bridge.sh` to create bridge bindings
2. Run `./scripts/build_rust.sh release` to build the Rust library
3. Set up your Flutter project structure
4. Copy the generated Dart file to your Flutter project
5. Implement your Flutter UI
6. Test thoroughly on all target platforms

---

## ğŸ“ Notes

- **Dual API Design**: This guide provides both OOP (struct wrappers) and utility functions - use what fits your needs
- **Build Outputs**: All build outputs are stored in the `build/` directory as requested
- **Separation of Concerns**: The bridge crate is separate from your core wallet logic
- **Extensibility**: You can extend `bridge.rs` with more structs and functions as needed
- **Type Safety**: OOP API provides full type safety with access to all struct methods
- **Compatibility**: Both APIs work together seamlessly - mix and match as needed
- **Production Ready**: Consider implementing proper error handling, logging, and security measures
- **CI/CD**: Add pipelines for automated building across platforms
- **Documentation**: The generated Dart code will have inline documentation from your Rust doc comments

---

**Happy coding! ğŸš€**
