// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import 'frb_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `clone`, `clone`, `fmt`, `fmt`, `from`, `from`

/// Generate a new BIP39 mnemonic phrase (returns string)
Future<String> generateMnemonic({required int wordCount}) =>
    RustLib.instance.api.crateBridgeGenerateMnemonic(wordCount: wordCount);

/// Validate a mnemonic phrase
Future<bool> validateMnemonic({required String phrase}) =>
    RustLib.instance.api.crateBridgeValidateMnemonic(phrase: phrase);

/// Create a master extended private key from a mnemonic string
Future<String> createMasterKey({
  required String mnemonic,
  String? passphrase,
  required NetworkType network,
}) => RustLib.instance.api.crateBridgeCreateMasterKey(
  mnemonic: mnemonic,
  passphrase: passphrase,
  network: network,
);

/// Derive a child key from an extended private key using a derivation path
Future<String> deriveKey({
  required String extendedKey,
  required String derivationPath,
}) => RustLib.instance.api.crateBridgeDeriveKey(
  extendedKey: extendedKey,
  derivationPath: derivationPath,
);

/// Get the public key from an extended private key string
Future<String> getPublicKey({required String extendedPrivateKey}) => RustLib
    .instance
    .api
    .crateBridgeGetPublicKey(extendedPrivateKey: extendedPrivateKey);

/// Get address from an extended private key at specific index
Future<String> getAddress({
  required String extendedPrivateKey,
  required int addressIndex,
}) => RustLib.instance.api.crateBridgeGetAddress(
  extendedPrivateKey: extendedPrivateKey,
  addressIndex: addressIndex,
);

/// Create a complete BIP44 wallet and return the account key
Future<WalletResult> createBip44Wallet({
  required String mnemonic,
  String? passphrase,
  required int accountIndex,
  required NetworkType network,
}) => RustLib.instance.api.crateBridgeCreateBip44Wallet(
  mnemonic: mnemonic,
  passphrase: passphrase,
  accountIndex: accountIndex,
  network: network,
);

/// Simple health check function
Future<String> healthCheck() => RustLib.instance.api.crateBridgeHealthCheck();

/// Add two numbers (example from the article)
Future<int> add({required int a, required int b}) =>
    RustLib.instance.api.crateBridgeAdd(a: a, b: b);

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ExtendedPrivateKey>>
abstract class ExtendedPrivateKey implements RustOpaqueInterface {
  /// Get the child number index
  Future<int> childNumberIndex();

  /// Get the depth in derivation tree (0 = master, 1 = level-1 child, etc.)
  Future<int> depth();

  /// Derive a single child key
  Future<ExtendedPrivateKey> deriveChild({
    required int index,
    required bool hardened,
  });

  /// Derive using a path string (e.g., "m/44'/0'/0'/0/0")
  Future<ExtendedPrivateKey> derivePath({required String path});

  /// Get this key's fingerprint (4 bytes)
  Future<Uint8List> fingerprint();

  /// Create master key from mnemonic
  static Future<ExtendedPrivateKey> fromMnemonic({
    required Mnemonic mnemonic,
    String? passphrase,
    required NetworkType network,
  }) => RustLib.instance.api.crateBridgeExtendedPrivateKeyFromMnemonic(
    mnemonic: mnemonic,
    passphrase: passphrase,
    network: network,
  );

  /// Create master key from seed bytes
  static Future<ExtendedPrivateKey> fromSeed({
    required List<int> seed,
    required NetworkType network,
  }) => RustLib.instance.api.crateBridgeExtendedPrivateKeyFromSeed(
    seed: seed,
    network: network,
  );

  /// Parse from string (xprv... format)
  static Future<ExtendedPrivateKey> fromString({required String s}) =>
      RustLib.instance.api.crateBridgeExtendedPrivateKeyFromString(s: s);

  /// Check if this is a hardened key
  Future<bool> isHardened();

  /// Get the network this key belongs to
  Future<NetworkType> network();

  /// Get the parent fingerprint (4 bytes)
  Future<Uint8List> parentFingerprint();

  /// Convert to extended public key
  Future<ExtendedPublicKey> toExtendedPublicKey();

  /// Serialize to extended key string (xprv... format)
  Future<String> toExtendedString();
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ExtendedPublicKey>>
abstract class ExtendedPublicKey implements RustOpaqueInterface {
  /// Get the child number index
  Future<int> childNumberIndex();

  /// Get the depth in derivation tree
  Future<int> depth();

  /// Derive a child public key (non-hardened only)
  Future<ExtendedPublicKey> deriveChild({required int index});

  /// Derive using a path string (only non-hardened paths allowed)
  Future<ExtendedPublicKey> derivePath({required String path});

  /// Get this key's fingerprint (4 bytes)
  Future<Uint8List> fingerprint();

  /// Parse from string (xpub... format)
  static Future<ExtendedPublicKey> fromString({required String s}) =>
      RustLib.instance.api.crateBridgeExtendedPublicKeyFromString(s: s);

  /// Check if this is a hardened key (public keys can only have non-hardened children)
  Future<bool> isHardened();

  /// Get the network this key belongs to
  Future<NetworkType> network();

  /// Get the parent fingerprint (4 bytes)
  Future<Uint8List> parentFingerprint();

  /// Serialize to extended key string (xpub... format)
  Future<String> toExtendedString();
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Mnemonic>>
abstract class Mnemonic implements RustOpaqueInterface {
  /// Parse mnemonic from phrase string
  static Future<Mnemonic> fromPhrase({required String phrase}) =>
      RustLib.instance.api.crateBridgeMnemonicFromPhrase(phrase: phrase);

  /// Generate a new mnemonic with specified word count
  static Future<Mnemonic> generate({required int wordCount}) =>
      RustLib.instance.api.crateBridgeMnemonicGenerate(wordCount: wordCount);

  /// Validate that this mnemonic is valid (always true for constructed mnemonics)
  Future<bool> isValid();

  /// Convert mnemonic to string phrase
  Future<String> toPhrase();

  /// Get the word count
  Future<int> wordCount();
}

/// Network type for the wallet
enum NetworkType { bitcoinMainnet, bitcoinTestnet }

/// Result type for wallet operations (used by utility functions)
class WalletResult {
  final bool success;
  final String message;
  final String? data;

  const WalletResult({required this.success, required this.message, this.data});

  @override
  int get hashCode => success.hashCode ^ message.hashCode ^ data.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is WalletResult &&
          runtimeType == other.runtimeType &&
          success == other.success &&
          message == other.message &&
          data == other.data;
}
