// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: unused_import, unused_element, unnecessary_import, duplicate_ignore, invalid_use_of_internal_member, annotate_overrides, non_constant_identifier_names, curly_braces_in_flow_control_structures, prefer_const_literals_to_create_immutables, unused_field

import 'bridge.dart';
import 'dart:async';
import 'dart:convert';
import 'frb_generated.dart';
import 'frb_generated.io.dart' if (dart.library.js_interop) 'frb_generated.web.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';


                /// Main entrypoint of the Rust API
                class RustLib extends BaseEntrypoint<RustLibApi, RustLibApiImpl, RustLibWire> {
                  @internal
                  static final instance = RustLib._();

                  RustLib._();

                  /// Initialize flutter_rust_bridge
                  static Future<void> init({
                    RustLibApi? api,
                    BaseHandler? handler,
                    ExternalLibrary? externalLibrary,
                    bool forceSameCodegenVersion = true,
                  }) async {
                    await instance.initImpl(
                      api: api,
                      handler: handler,
                      externalLibrary: externalLibrary,
                      forceSameCodegenVersion: forceSameCodegenVersion,
                    );
                  }

                  /// Initialize flutter_rust_bridge in mock mode.
                  /// No libraries for FFI are loaded.
                  static void initMock({
                    required RustLibApi api,
                  }) {
                    instance.initMockImpl(
                      api: api,
                    );
                  }

                  /// Dispose flutter_rust_bridge
                  ///
                  /// The call to this function is optional, since flutter_rust_bridge (and everything else)
                  /// is automatically disposed when the app stops.
                  static void dispose() => instance.disposeImpl();

                  @override
                  ApiImplConstructor<RustLibApiImpl, RustLibWire> get apiImplConstructor => RustLibApiImpl.new;

                  @override
                  WireConstructor<RustLibWire> get wireConstructor => RustLibWire.fromExternalLibrary;

                  @override
                  Future<void> executeRustInitializers() async {
                    
                  }

                  @override
                  ExternalLibraryLoaderConfig get defaultExternalLibraryLoaderConfig => kDefaultExternalLibraryLoaderConfig;

                  @override
                  String get codegenVersion => '2.11.1';

                  @override
                  int get rustContentHash => 261011709;

                  static const kDefaultExternalLibraryLoaderConfig = ExternalLibraryLoaderConfig(
                    stem: 'khodpay_flutter_bridge',
                    ioDirectory: '../../crates/flutter_bridge/target/release/',
                    webPrefix: 'pkg/',
                  );
                }
                

                abstract class RustLibApi extends BaseApi {
                  Future<Bip44Wallet> crateBridgeBip44WalletFromMnemonic({required String mnemonic , String? passphrase , required NetworkType network });

Future<Bip44Wallet> crateBridgeBip44WalletFromSeed({required List<int> seed , required NetworkType network });

Future<Bip44Account> crateBridgeBip44WalletGetAccount({required Bip44Wallet that , required PurposeType purpose , required CoinType coinType , required int accountIndex });

Future<NetworkType> crateBridgeBip44WalletNetwork({required Bip44Wallet that });

Future<int> crateBridgeExtendedPrivateKeyChildNumberIndex({required ExtendedPrivateKey that });

Future<int> crateBridgeExtendedPrivateKeyDepth({required ExtendedPrivateKey that });

Future<ExtendedPrivateKey> crateBridgeExtendedPrivateKeyDeriveChild({required ExtendedPrivateKey that , required int index , required bool hardened });

Future<ExtendedPrivateKey> crateBridgeExtendedPrivateKeyDerivePath({required ExtendedPrivateKey that , required String path });

Future<Uint8List> crateBridgeExtendedPrivateKeyFingerprint({required ExtendedPrivateKey that });

Future<ExtendedPrivateKey> crateBridgeExtendedPrivateKeyFromMnemonic({required Mnemonic mnemonic , String? passphrase , required NetworkType network });

Future<ExtendedPrivateKey> crateBridgeExtendedPrivateKeyFromSeed({required List<int> seed , required NetworkType network });

Future<ExtendedPrivateKey> crateBridgeExtendedPrivateKeyFromString({required String s });

Future<bool> crateBridgeExtendedPrivateKeyIsHardened({required ExtendedPrivateKey that });

Future<NetworkType> crateBridgeExtendedPrivateKeyNetwork({required ExtendedPrivateKey that });

Future<Uint8List> crateBridgeExtendedPrivateKeyParentFingerprint({required ExtendedPrivateKey that });

Future<ExtendedPublicKey> crateBridgeExtendedPrivateKeyToExtendedPublicKey({required ExtendedPrivateKey that });

Future<String> crateBridgeExtendedPrivateKeyToExtendedString({required ExtendedPrivateKey that });

Future<int> crateBridgeExtendedPublicKeyChildNumberIndex({required ExtendedPublicKey that });

Future<int> crateBridgeExtendedPublicKeyDepth({required ExtendedPublicKey that });

Future<ExtendedPublicKey> crateBridgeExtendedPublicKeyDeriveChild({required ExtendedPublicKey that , required int index });

Future<ExtendedPublicKey> crateBridgeExtendedPublicKeyDerivePath({required ExtendedPublicKey that , required String path });

Future<Uint8List> crateBridgeExtendedPublicKeyFingerprint({required ExtendedPublicKey that });

Future<ExtendedPublicKey> crateBridgeExtendedPublicKeyFromString({required String s });

Future<bool> crateBridgeExtendedPublicKeyIsHardened({required ExtendedPublicKey that });

Future<NetworkType> crateBridgeExtendedPublicKeyNetwork({required ExtendedPublicKey that });

Future<Uint8List> crateBridgeExtendedPublicKeyParentFingerprint({required ExtendedPublicKey that });

Future<String> crateBridgeExtendedPublicKeyToExtendedString({required ExtendedPublicKey that });

Future<Mnemonic> crateBridgeMnemonicFromPhrase({required String phrase });

Future<Mnemonic> crateBridgeMnemonicGenerate({required int wordCount });

Future<bool> crateBridgeMnemonicIsValid({required Mnemonic that });

Future<String> crateBridgeMnemonicToPhrase({required Mnemonic that });

Future<int> crateBridgeMnemonicWordCount({required Mnemonic that });

Future<int> crateBridgeAdd({required int a , required int b });

Future<List<String>> crateBridgeBip44AccountDeriveAddressRange({required Bip44Account that , required ChainType chain , required int start , required int count });

Future<String> crateBridgeBip44AccountDeriveExternal({required Bip44Account that , required int index });

Future<String> crateBridgeBip44AccountDeriveInternal({required Bip44Account that , required int index });

Future<String> crateBridgeCreateBip44Account({required String mnemonic , String? passphrase , required PurposeType purpose , required CoinType coinType , required int accountIndex , required NetworkType network });

Future<WalletResult> crateBridgeCreateBip44Wallet({required String mnemonic , String? passphrase , required int accountIndex , required NetworkType network });

Future<String> crateBridgeCreateMasterKey({required String mnemonic , String? passphrase , required NetworkType network });

Future<String> crateBridgeDeriveBip44Address({required String accountKey , required ChainType chain , required int addressIndex });

Future<String> crateBridgeDeriveKey({required String extendedKey , required String derivationPath });

Future<String> crateBridgeGenerateMnemonic({required int wordCount });

Future<String> crateBridgeGetAddress({required String extendedPrivateKey , required int addressIndex });

Future<WalletResult> crateBridgeGetCoinInfo({required CoinType coinType });

Future<String> crateBridgeGetPublicKey({required String extendedPrivateKey });

Future<WalletResult> crateBridgeGetPurposeInfo({required PurposeType purpose });

Future<String> crateBridgeHealthCheck();

Future<WalletResult> crateBridgeParseBip44Path({required String path });

Future<bool> crateBridgeValidateMnemonic({required String phrase });

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_Bip44Wallet;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_Bip44Wallet;

CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_Bip44WalletPtr;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_ExtendedPrivateKey;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_ExtendedPrivateKey;

CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_ExtendedPrivateKeyPtr;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_ExtendedPublicKey;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_ExtendedPublicKey;

CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_ExtendedPublicKeyPtr;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_Mnemonic;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_Mnemonic;

CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_MnemonicPtr;


                }
                

                class RustLibApiImpl extends RustLibApiImplPlatform implements RustLibApi {
                  RustLibApiImpl({
                    required super.handler,
                    required super.wire,
                    required super.generalizedFrbRustBinding,
                    required super.portManager,
                  });

                  @override Future<Bip44Wallet> crateBridgeBip44WalletFromMnemonic({required String mnemonic , String? passphrase , required NetworkType network })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_String(mnemonic, serializer);
sse_encode_opt_String(passphrase, serializer);
sse_encode_network_type(network, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 1, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBip44Wallet,
          decodeErrorData: sse_decode_String,
        )
        ,
            constMeta: kCrateBridgeBip44WalletFromMnemonicConstMeta,
            argValues: [mnemonic, passphrase, network],
            apiImpl: this,
        )); }


        TaskConstMeta get kCrateBridgeBip44WalletFromMnemonicConstMeta => const TaskConstMeta(
            debugName: "Bip44Wallet_from_mnemonic",
            argNames: ["mnemonic", "passphrase", "network"],
        );
        

@override Future<Bip44Wallet> crateBridgeBip44WalletFromSeed({required List<int> seed , required NetworkType network })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_list_prim_u_8_loose(seed, serializer);
sse_encode_network_type(network, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 2, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBip44Wallet,
          decodeErrorData: sse_decode_String,
        )
        ,
            constMeta: kCrateBridgeBip44WalletFromSeedConstMeta,
            argValues: [seed, network],
            apiImpl: this,
        )); }


        TaskConstMeta get kCrateBridgeBip44WalletFromSeedConstMeta => const TaskConstMeta(
            debugName: "Bip44Wallet_from_seed",
            argNames: ["seed", "network"],
        );
        

@override Future<Bip44Account> crateBridgeBip44WalletGetAccount({required Bip44Wallet that , required PurposeType purpose , required CoinType coinType , required int accountIndex })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBip44Wallet(that, serializer);
sse_encode_purpose_type(purpose, serializer);
sse_encode_box_autoadd_coin_type(coinType, serializer);
sse_encode_u_32(accountIndex, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 3, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_bip_44_account,
          decodeErrorData: sse_decode_String,
        )
        ,
            constMeta: kCrateBridgeBip44WalletGetAccountConstMeta,
            argValues: [that, purpose, coinType, accountIndex],
            apiImpl: this,
        )); }


        TaskConstMeta get kCrateBridgeBip44WalletGetAccountConstMeta => const TaskConstMeta(
            debugName: "Bip44Wallet_get_account",
            argNames: ["that", "purpose", "coinType", "accountIndex"],
        );
        

@override Future<NetworkType> crateBridgeBip44WalletNetwork({required Bip44Wallet that })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBip44Wallet(that, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 4, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_network_type,
          decodeErrorData: null,
        )
        ,
            constMeta: kCrateBridgeBip44WalletNetworkConstMeta,
            argValues: [that],
            apiImpl: this,
        )); }


        TaskConstMeta get kCrateBridgeBip44WalletNetworkConstMeta => const TaskConstMeta(
            debugName: "Bip44Wallet_network",
            argNames: ["that"],
        );
        

@override Future<int> crateBridgeExtendedPrivateKeyChildNumberIndex({required ExtendedPrivateKey that })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerExtendedPrivateKey(that, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 5, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_u_32,
          decodeErrorData: null,
        )
        ,
            constMeta: kCrateBridgeExtendedPrivateKeyChildNumberIndexConstMeta,
            argValues: [that],
            apiImpl: this,
        )); }


        TaskConstMeta get kCrateBridgeExtendedPrivateKeyChildNumberIndexConstMeta => const TaskConstMeta(
            debugName: "ExtendedPrivateKey_child_number_index",
            argNames: ["that"],
        );
        

@override Future<int> crateBridgeExtendedPrivateKeyDepth({required ExtendedPrivateKey that })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerExtendedPrivateKey(that, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 6, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_u_8,
          decodeErrorData: null,
        )
        ,
            constMeta: kCrateBridgeExtendedPrivateKeyDepthConstMeta,
            argValues: [that],
            apiImpl: this,
        )); }


        TaskConstMeta get kCrateBridgeExtendedPrivateKeyDepthConstMeta => const TaskConstMeta(
            debugName: "ExtendedPrivateKey_depth",
            argNames: ["that"],
        );
        

@override Future<ExtendedPrivateKey> crateBridgeExtendedPrivateKeyDeriveChild({required ExtendedPrivateKey that , required int index , required bool hardened })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerExtendedPrivateKey(that, serializer);
sse_encode_u_32(index, serializer);
sse_encode_bool(hardened, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 7, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerExtendedPrivateKey,
          decodeErrorData: sse_decode_String,
        )
        ,
            constMeta: kCrateBridgeExtendedPrivateKeyDeriveChildConstMeta,
            argValues: [that, index, hardened],
            apiImpl: this,
        )); }


        TaskConstMeta get kCrateBridgeExtendedPrivateKeyDeriveChildConstMeta => const TaskConstMeta(
            debugName: "ExtendedPrivateKey_derive_child",
            argNames: ["that", "index", "hardened"],
        );
        

@override Future<ExtendedPrivateKey> crateBridgeExtendedPrivateKeyDerivePath({required ExtendedPrivateKey that , required String path })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerExtendedPrivateKey(that, serializer);
sse_encode_String(path, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 8, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerExtendedPrivateKey,
          decodeErrorData: sse_decode_String,
        )
        ,
            constMeta: kCrateBridgeExtendedPrivateKeyDerivePathConstMeta,
            argValues: [that, path],
            apiImpl: this,
        )); }


        TaskConstMeta get kCrateBridgeExtendedPrivateKeyDerivePathConstMeta => const TaskConstMeta(
            debugName: "ExtendedPrivateKey_derive_path",
            argNames: ["that", "path"],
        );
        

@override Future<Uint8List> crateBridgeExtendedPrivateKeyFingerprint({required ExtendedPrivateKey that })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerExtendedPrivateKey(that, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 9, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_list_prim_u_8_strict,
          decodeErrorData: null,
        )
        ,
            constMeta: kCrateBridgeExtendedPrivateKeyFingerprintConstMeta,
            argValues: [that],
            apiImpl: this,
        )); }


        TaskConstMeta get kCrateBridgeExtendedPrivateKeyFingerprintConstMeta => const TaskConstMeta(
            debugName: "ExtendedPrivateKey_fingerprint",
            argNames: ["that"],
        );
        

@override Future<ExtendedPrivateKey> crateBridgeExtendedPrivateKeyFromMnemonic({required Mnemonic mnemonic , String? passphrase , required NetworkType network })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMnemonic(mnemonic, serializer);
sse_encode_opt_String(passphrase, serializer);
sse_encode_network_type(network, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 10, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerExtendedPrivateKey,
          decodeErrorData: sse_decode_String,
        )
        ,
            constMeta: kCrateBridgeExtendedPrivateKeyFromMnemonicConstMeta,
            argValues: [mnemonic, passphrase, network],
            apiImpl: this,
        )); }


        TaskConstMeta get kCrateBridgeExtendedPrivateKeyFromMnemonicConstMeta => const TaskConstMeta(
            debugName: "ExtendedPrivateKey_from_mnemonic",
            argNames: ["mnemonic", "passphrase", "network"],
        );
        

@override Future<ExtendedPrivateKey> crateBridgeExtendedPrivateKeyFromSeed({required List<int> seed , required NetworkType network })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_list_prim_u_8_loose(seed, serializer);
sse_encode_network_type(network, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 11, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerExtendedPrivateKey,
          decodeErrorData: sse_decode_String,
        )
        ,
            constMeta: kCrateBridgeExtendedPrivateKeyFromSeedConstMeta,
            argValues: [seed, network],
            apiImpl: this,
        )); }


        TaskConstMeta get kCrateBridgeExtendedPrivateKeyFromSeedConstMeta => const TaskConstMeta(
            debugName: "ExtendedPrivateKey_from_seed",
            argNames: ["seed", "network"],
        );
        

@override Future<ExtendedPrivateKey> crateBridgeExtendedPrivateKeyFromString({required String s })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_String(s, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 12, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerExtendedPrivateKey,
          decodeErrorData: sse_decode_String,
        )
        ,
            constMeta: kCrateBridgeExtendedPrivateKeyFromStringConstMeta,
            argValues: [s],
            apiImpl: this,
        )); }


        TaskConstMeta get kCrateBridgeExtendedPrivateKeyFromStringConstMeta => const TaskConstMeta(
            debugName: "ExtendedPrivateKey_from_string",
            argNames: ["s"],
        );
        

@override Future<bool> crateBridgeExtendedPrivateKeyIsHardened({required ExtendedPrivateKey that })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerExtendedPrivateKey(that, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 13, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_bool,
          decodeErrorData: null,
        )
        ,
            constMeta: kCrateBridgeExtendedPrivateKeyIsHardenedConstMeta,
            argValues: [that],
            apiImpl: this,
        )); }


        TaskConstMeta get kCrateBridgeExtendedPrivateKeyIsHardenedConstMeta => const TaskConstMeta(
            debugName: "ExtendedPrivateKey_is_hardened",
            argNames: ["that"],
        );
        

@override Future<NetworkType> crateBridgeExtendedPrivateKeyNetwork({required ExtendedPrivateKey that })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerExtendedPrivateKey(that, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 14, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_network_type,
          decodeErrorData: null,
        )
        ,
            constMeta: kCrateBridgeExtendedPrivateKeyNetworkConstMeta,
            argValues: [that],
            apiImpl: this,
        )); }


        TaskConstMeta get kCrateBridgeExtendedPrivateKeyNetworkConstMeta => const TaskConstMeta(
            debugName: "ExtendedPrivateKey_network",
            argNames: ["that"],
        );
        

@override Future<Uint8List> crateBridgeExtendedPrivateKeyParentFingerprint({required ExtendedPrivateKey that })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerExtendedPrivateKey(that, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 15, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_list_prim_u_8_strict,
          decodeErrorData: null,
        )
        ,
            constMeta: kCrateBridgeExtendedPrivateKeyParentFingerprintConstMeta,
            argValues: [that],
            apiImpl: this,
        )); }


        TaskConstMeta get kCrateBridgeExtendedPrivateKeyParentFingerprintConstMeta => const TaskConstMeta(
            debugName: "ExtendedPrivateKey_parent_fingerprint",
            argNames: ["that"],
        );
        

@override Future<ExtendedPublicKey> crateBridgeExtendedPrivateKeyToExtendedPublicKey({required ExtendedPrivateKey that })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerExtendedPrivateKey(that, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 16, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerExtendedPublicKey,
          decodeErrorData: null,
        )
        ,
            constMeta: kCrateBridgeExtendedPrivateKeyToExtendedPublicKeyConstMeta,
            argValues: [that],
            apiImpl: this,
        )); }


        TaskConstMeta get kCrateBridgeExtendedPrivateKeyToExtendedPublicKeyConstMeta => const TaskConstMeta(
            debugName: "ExtendedPrivateKey_to_extended_public_key",
            argNames: ["that"],
        );
        

@override Future<String> crateBridgeExtendedPrivateKeyToExtendedString({required ExtendedPrivateKey that })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerExtendedPrivateKey(that, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 17, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_String,
          decodeErrorData: null,
        )
        ,
            constMeta: kCrateBridgeExtendedPrivateKeyToExtendedStringConstMeta,
            argValues: [that],
            apiImpl: this,
        )); }


        TaskConstMeta get kCrateBridgeExtendedPrivateKeyToExtendedStringConstMeta => const TaskConstMeta(
            debugName: "ExtendedPrivateKey_to_extended_string",
            argNames: ["that"],
        );
        

@override Future<int> crateBridgeExtendedPublicKeyChildNumberIndex({required ExtendedPublicKey that })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerExtendedPublicKey(that, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 18, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_u_32,
          decodeErrorData: null,
        )
        ,
            constMeta: kCrateBridgeExtendedPublicKeyChildNumberIndexConstMeta,
            argValues: [that],
            apiImpl: this,
        )); }


        TaskConstMeta get kCrateBridgeExtendedPublicKeyChildNumberIndexConstMeta => const TaskConstMeta(
            debugName: "ExtendedPublicKey_child_number_index",
            argNames: ["that"],
        );
        

@override Future<int> crateBridgeExtendedPublicKeyDepth({required ExtendedPublicKey that })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerExtendedPublicKey(that, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 19, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_u_8,
          decodeErrorData: null,
        )
        ,
            constMeta: kCrateBridgeExtendedPublicKeyDepthConstMeta,
            argValues: [that],
            apiImpl: this,
        )); }


        TaskConstMeta get kCrateBridgeExtendedPublicKeyDepthConstMeta => const TaskConstMeta(
            debugName: "ExtendedPublicKey_depth",
            argNames: ["that"],
        );
        

@override Future<ExtendedPublicKey> crateBridgeExtendedPublicKeyDeriveChild({required ExtendedPublicKey that , required int index })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerExtendedPublicKey(that, serializer);
sse_encode_u_32(index, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 20, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerExtendedPublicKey,
          decodeErrorData: sse_decode_String,
        )
        ,
            constMeta: kCrateBridgeExtendedPublicKeyDeriveChildConstMeta,
            argValues: [that, index],
            apiImpl: this,
        )); }


        TaskConstMeta get kCrateBridgeExtendedPublicKeyDeriveChildConstMeta => const TaskConstMeta(
            debugName: "ExtendedPublicKey_derive_child",
            argNames: ["that", "index"],
        );
        

@override Future<ExtendedPublicKey> crateBridgeExtendedPublicKeyDerivePath({required ExtendedPublicKey that , required String path })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerExtendedPublicKey(that, serializer);
sse_encode_String(path, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 21, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerExtendedPublicKey,
          decodeErrorData: sse_decode_String,
        )
        ,
            constMeta: kCrateBridgeExtendedPublicKeyDerivePathConstMeta,
            argValues: [that, path],
            apiImpl: this,
        )); }


        TaskConstMeta get kCrateBridgeExtendedPublicKeyDerivePathConstMeta => const TaskConstMeta(
            debugName: "ExtendedPublicKey_derive_path",
            argNames: ["that", "path"],
        );
        

@override Future<Uint8List> crateBridgeExtendedPublicKeyFingerprint({required ExtendedPublicKey that })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerExtendedPublicKey(that, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 22, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_list_prim_u_8_strict,
          decodeErrorData: null,
        )
        ,
            constMeta: kCrateBridgeExtendedPublicKeyFingerprintConstMeta,
            argValues: [that],
            apiImpl: this,
        )); }


        TaskConstMeta get kCrateBridgeExtendedPublicKeyFingerprintConstMeta => const TaskConstMeta(
            debugName: "ExtendedPublicKey_fingerprint",
            argNames: ["that"],
        );
        

@override Future<ExtendedPublicKey> crateBridgeExtendedPublicKeyFromString({required String s })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_String(s, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 23, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerExtendedPublicKey,
          decodeErrorData: sse_decode_String,
        )
        ,
            constMeta: kCrateBridgeExtendedPublicKeyFromStringConstMeta,
            argValues: [s],
            apiImpl: this,
        )); }


        TaskConstMeta get kCrateBridgeExtendedPublicKeyFromStringConstMeta => const TaskConstMeta(
            debugName: "ExtendedPublicKey_from_string",
            argNames: ["s"],
        );
        

@override Future<bool> crateBridgeExtendedPublicKeyIsHardened({required ExtendedPublicKey that })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerExtendedPublicKey(that, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 24, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_bool,
          decodeErrorData: null,
        )
        ,
            constMeta: kCrateBridgeExtendedPublicKeyIsHardenedConstMeta,
            argValues: [that],
            apiImpl: this,
        )); }


        TaskConstMeta get kCrateBridgeExtendedPublicKeyIsHardenedConstMeta => const TaskConstMeta(
            debugName: "ExtendedPublicKey_is_hardened",
            argNames: ["that"],
        );
        

@override Future<NetworkType> crateBridgeExtendedPublicKeyNetwork({required ExtendedPublicKey that })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerExtendedPublicKey(that, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 25, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_network_type,
          decodeErrorData: null,
        )
        ,
            constMeta: kCrateBridgeExtendedPublicKeyNetworkConstMeta,
            argValues: [that],
            apiImpl: this,
        )); }


        TaskConstMeta get kCrateBridgeExtendedPublicKeyNetworkConstMeta => const TaskConstMeta(
            debugName: "ExtendedPublicKey_network",
            argNames: ["that"],
        );
        

@override Future<Uint8List> crateBridgeExtendedPublicKeyParentFingerprint({required ExtendedPublicKey that })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerExtendedPublicKey(that, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 26, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_list_prim_u_8_strict,
          decodeErrorData: null,
        )
        ,
            constMeta: kCrateBridgeExtendedPublicKeyParentFingerprintConstMeta,
            argValues: [that],
            apiImpl: this,
        )); }


        TaskConstMeta get kCrateBridgeExtendedPublicKeyParentFingerprintConstMeta => const TaskConstMeta(
            debugName: "ExtendedPublicKey_parent_fingerprint",
            argNames: ["that"],
        );
        

@override Future<String> crateBridgeExtendedPublicKeyToExtendedString({required ExtendedPublicKey that })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerExtendedPublicKey(that, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 27, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_String,
          decodeErrorData: null,
        )
        ,
            constMeta: kCrateBridgeExtendedPublicKeyToExtendedStringConstMeta,
            argValues: [that],
            apiImpl: this,
        )); }


        TaskConstMeta get kCrateBridgeExtendedPublicKeyToExtendedStringConstMeta => const TaskConstMeta(
            debugName: "ExtendedPublicKey_to_extended_string",
            argNames: ["that"],
        );
        

@override Future<Mnemonic> crateBridgeMnemonicFromPhrase({required String phrase })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_String(phrase, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 28, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMnemonic,
          decodeErrorData: sse_decode_String,
        )
        ,
            constMeta: kCrateBridgeMnemonicFromPhraseConstMeta,
            argValues: [phrase],
            apiImpl: this,
        )); }


        TaskConstMeta get kCrateBridgeMnemonicFromPhraseConstMeta => const TaskConstMeta(
            debugName: "Mnemonic_from_phrase",
            argNames: ["phrase"],
        );
        

@override Future<Mnemonic> crateBridgeMnemonicGenerate({required int wordCount })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_u_32(wordCount, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 29, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMnemonic,
          decodeErrorData: sse_decode_String,
        )
        ,
            constMeta: kCrateBridgeMnemonicGenerateConstMeta,
            argValues: [wordCount],
            apiImpl: this,
        )); }


        TaskConstMeta get kCrateBridgeMnemonicGenerateConstMeta => const TaskConstMeta(
            debugName: "Mnemonic_generate",
            argNames: ["wordCount"],
        );
        

@override Future<bool> crateBridgeMnemonicIsValid({required Mnemonic that })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMnemonic(that, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 30, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_bool,
          decodeErrorData: null,
        )
        ,
            constMeta: kCrateBridgeMnemonicIsValidConstMeta,
            argValues: [that],
            apiImpl: this,
        )); }


        TaskConstMeta get kCrateBridgeMnemonicIsValidConstMeta => const TaskConstMeta(
            debugName: "Mnemonic_is_valid",
            argNames: ["that"],
        );
        

@override Future<String> crateBridgeMnemonicToPhrase({required Mnemonic that })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMnemonic(that, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 31, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_String,
          decodeErrorData: null,
        )
        ,
            constMeta: kCrateBridgeMnemonicToPhraseConstMeta,
            argValues: [that],
            apiImpl: this,
        )); }


        TaskConstMeta get kCrateBridgeMnemonicToPhraseConstMeta => const TaskConstMeta(
            debugName: "Mnemonic_to_phrase",
            argNames: ["that"],
        );
        

@override Future<int> crateBridgeMnemonicWordCount({required Mnemonic that })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMnemonic(that, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 32, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_u_32,
          decodeErrorData: null,
        )
        ,
            constMeta: kCrateBridgeMnemonicWordCountConstMeta,
            argValues: [that],
            apiImpl: this,
        )); }


        TaskConstMeta get kCrateBridgeMnemonicWordCountConstMeta => const TaskConstMeta(
            debugName: "Mnemonic_word_count",
            argNames: ["that"],
        );
        

@override Future<int> crateBridgeAdd({required int a , required int b })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_i_32(a, serializer);
sse_encode_i_32(b, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 33, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_i_32,
          decodeErrorData: null,
        )
        ,
            constMeta: kCrateBridgeAddConstMeta,
            argValues: [a, b],
            apiImpl: this,
        )); }


        TaskConstMeta get kCrateBridgeAddConstMeta => const TaskConstMeta(
            debugName: "add",
            argNames: ["a", "b"],
        );
        

@override Future<List<String>> crateBridgeBip44AccountDeriveAddressRange({required Bip44Account that , required ChainType chain , required int start , required int count })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_box_autoadd_bip_44_account(that, serializer);
sse_encode_chain_type(chain, serializer);
sse_encode_u_32(start, serializer);
sse_encode_u_32(count, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 34, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_list_String,
          decodeErrorData: sse_decode_String,
        )
        ,
            constMeta: kCrateBridgeBip44AccountDeriveAddressRangeConstMeta,
            argValues: [that, chain, start, count],
            apiImpl: this,
        )); }


        TaskConstMeta get kCrateBridgeBip44AccountDeriveAddressRangeConstMeta => const TaskConstMeta(
            debugName: "bip_44_account_derive_address_range",
            argNames: ["that", "chain", "start", "count"],
        );
        

@override Future<String> crateBridgeBip44AccountDeriveExternal({required Bip44Account that , required int index })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_box_autoadd_bip_44_account(that, serializer);
sse_encode_u_32(index, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 35, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_String,
          decodeErrorData: sse_decode_String,
        )
        ,
            constMeta: kCrateBridgeBip44AccountDeriveExternalConstMeta,
            argValues: [that, index],
            apiImpl: this,
        )); }


        TaskConstMeta get kCrateBridgeBip44AccountDeriveExternalConstMeta => const TaskConstMeta(
            debugName: "bip_44_account_derive_external",
            argNames: ["that", "index"],
        );
        

@override Future<String> crateBridgeBip44AccountDeriveInternal({required Bip44Account that , required int index })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_box_autoadd_bip_44_account(that, serializer);
sse_encode_u_32(index, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 36, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_String,
          decodeErrorData: sse_decode_String,
        )
        ,
            constMeta: kCrateBridgeBip44AccountDeriveInternalConstMeta,
            argValues: [that, index],
            apiImpl: this,
        )); }


        TaskConstMeta get kCrateBridgeBip44AccountDeriveInternalConstMeta => const TaskConstMeta(
            debugName: "bip_44_account_derive_internal",
            argNames: ["that", "index"],
        );
        

@override Future<String> crateBridgeCreateBip44Account({required String mnemonic , String? passphrase , required PurposeType purpose , required CoinType coinType , required int accountIndex , required NetworkType network })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_String(mnemonic, serializer);
sse_encode_opt_String(passphrase, serializer);
sse_encode_purpose_type(purpose, serializer);
sse_encode_box_autoadd_coin_type(coinType, serializer);
sse_encode_u_32(accountIndex, serializer);
sse_encode_network_type(network, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 37, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_String,
          decodeErrorData: sse_decode_String,
        )
        ,
            constMeta: kCrateBridgeCreateBip44AccountConstMeta,
            argValues: [mnemonic, passphrase, purpose, coinType, accountIndex, network],
            apiImpl: this,
        )); }


        TaskConstMeta get kCrateBridgeCreateBip44AccountConstMeta => const TaskConstMeta(
            debugName: "create_bip44_account",
            argNames: ["mnemonic", "passphrase", "purpose", "coinType", "accountIndex", "network"],
        );
        

@override Future<WalletResult> crateBridgeCreateBip44Wallet({required String mnemonic , String? passphrase , required int accountIndex , required NetworkType network })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_String(mnemonic, serializer);
sse_encode_opt_String(passphrase, serializer);
sse_encode_u_32(accountIndex, serializer);
sse_encode_network_type(network, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 38, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_wallet_result,
          decodeErrorData: sse_decode_String,
        )
        ,
            constMeta: kCrateBridgeCreateBip44WalletConstMeta,
            argValues: [mnemonic, passphrase, accountIndex, network],
            apiImpl: this,
        )); }


        TaskConstMeta get kCrateBridgeCreateBip44WalletConstMeta => const TaskConstMeta(
            debugName: "create_bip44_wallet",
            argNames: ["mnemonic", "passphrase", "accountIndex", "network"],
        );
        

@override Future<String> crateBridgeCreateMasterKey({required String mnemonic , String? passphrase , required NetworkType network })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_String(mnemonic, serializer);
sse_encode_opt_String(passphrase, serializer);
sse_encode_network_type(network, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 39, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_String,
          decodeErrorData: sse_decode_String,
        )
        ,
            constMeta: kCrateBridgeCreateMasterKeyConstMeta,
            argValues: [mnemonic, passphrase, network],
            apiImpl: this,
        )); }


        TaskConstMeta get kCrateBridgeCreateMasterKeyConstMeta => const TaskConstMeta(
            debugName: "create_master_key",
            argNames: ["mnemonic", "passphrase", "network"],
        );
        

@override Future<String> crateBridgeDeriveBip44Address({required String accountKey , required ChainType chain , required int addressIndex })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_String(accountKey, serializer);
sse_encode_chain_type(chain, serializer);
sse_encode_u_32(addressIndex, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 40, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_String,
          decodeErrorData: sse_decode_String,
        )
        ,
            constMeta: kCrateBridgeDeriveBip44AddressConstMeta,
            argValues: [accountKey, chain, addressIndex],
            apiImpl: this,
        )); }


        TaskConstMeta get kCrateBridgeDeriveBip44AddressConstMeta => const TaskConstMeta(
            debugName: "derive_bip44_address",
            argNames: ["accountKey", "chain", "addressIndex"],
        );
        

@override Future<String> crateBridgeDeriveKey({required String extendedKey , required String derivationPath })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_String(extendedKey, serializer);
sse_encode_String(derivationPath, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 41, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_String,
          decodeErrorData: sse_decode_String,
        )
        ,
            constMeta: kCrateBridgeDeriveKeyConstMeta,
            argValues: [extendedKey, derivationPath],
            apiImpl: this,
        )); }


        TaskConstMeta get kCrateBridgeDeriveKeyConstMeta => const TaskConstMeta(
            debugName: "derive_key",
            argNames: ["extendedKey", "derivationPath"],
        );
        

@override Future<String> crateBridgeGenerateMnemonic({required int wordCount })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_u_32(wordCount, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 42, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_String,
          decodeErrorData: sse_decode_String,
        )
        ,
            constMeta: kCrateBridgeGenerateMnemonicConstMeta,
            argValues: [wordCount],
            apiImpl: this,
        )); }


        TaskConstMeta get kCrateBridgeGenerateMnemonicConstMeta => const TaskConstMeta(
            debugName: "generate_mnemonic",
            argNames: ["wordCount"],
        );
        

@override Future<String> crateBridgeGetAddress({required String extendedPrivateKey , required int addressIndex })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_String(extendedPrivateKey, serializer);
sse_encode_u_32(addressIndex, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 43, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_String,
          decodeErrorData: sse_decode_String,
        )
        ,
            constMeta: kCrateBridgeGetAddressConstMeta,
            argValues: [extendedPrivateKey, addressIndex],
            apiImpl: this,
        )); }


        TaskConstMeta get kCrateBridgeGetAddressConstMeta => const TaskConstMeta(
            debugName: "get_address",
            argNames: ["extendedPrivateKey", "addressIndex"],
        );
        

@override Future<WalletResult> crateBridgeGetCoinInfo({required CoinType coinType })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_box_autoadd_coin_type(coinType, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 44, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_wallet_result,
          decodeErrorData: null,
        )
        ,
            constMeta: kCrateBridgeGetCoinInfoConstMeta,
            argValues: [coinType],
            apiImpl: this,
        )); }


        TaskConstMeta get kCrateBridgeGetCoinInfoConstMeta => const TaskConstMeta(
            debugName: "get_coin_info",
            argNames: ["coinType"],
        );
        

@override Future<String> crateBridgeGetPublicKey({required String extendedPrivateKey })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_String(extendedPrivateKey, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 45, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_String,
          decodeErrorData: sse_decode_String,
        )
        ,
            constMeta: kCrateBridgeGetPublicKeyConstMeta,
            argValues: [extendedPrivateKey],
            apiImpl: this,
        )); }


        TaskConstMeta get kCrateBridgeGetPublicKeyConstMeta => const TaskConstMeta(
            debugName: "get_public_key",
            argNames: ["extendedPrivateKey"],
        );
        

@override Future<WalletResult> crateBridgeGetPurposeInfo({required PurposeType purpose })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_purpose_type(purpose, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 46, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_wallet_result,
          decodeErrorData: null,
        )
        ,
            constMeta: kCrateBridgeGetPurposeInfoConstMeta,
            argValues: [purpose],
            apiImpl: this,
        )); }


        TaskConstMeta get kCrateBridgeGetPurposeInfoConstMeta => const TaskConstMeta(
            debugName: "get_purpose_info",
            argNames: ["purpose"],
        );
        

@override Future<String> crateBridgeHealthCheck()  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 47, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_String,
          decodeErrorData: null,
        )
        ,
            constMeta: kCrateBridgeHealthCheckConstMeta,
            argValues: [],
            apiImpl: this,
        )); }


        TaskConstMeta get kCrateBridgeHealthCheckConstMeta => const TaskConstMeta(
            debugName: "health_check",
            argNames: [],
        );
        

@override Future<WalletResult> crateBridgeParseBip44Path({required String path })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_String(path, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 48, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_wallet_result,
          decodeErrorData: sse_decode_String,
        )
        ,
            constMeta: kCrateBridgeParseBip44PathConstMeta,
            argValues: [path],
            apiImpl: this,
        )); }


        TaskConstMeta get kCrateBridgeParseBip44PathConstMeta => const TaskConstMeta(
            debugName: "parse_bip44_path",
            argNames: ["path"],
        );
        

@override Future<bool> crateBridgeValidateMnemonic({required String phrase })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_String(phrase, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 49, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_bool,
          decodeErrorData: null,
        )
        ,
            constMeta: kCrateBridgeValidateMnemonicConstMeta,
            argValues: [phrase],
            apiImpl: this,
        )); }


        TaskConstMeta get kCrateBridgeValidateMnemonicConstMeta => const TaskConstMeta(
            debugName: "validate_mnemonic",
            argNames: ["phrase"],
        );
        

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_Bip44Wallet => wire.rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBip44Wallet;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_Bip44Wallet => wire.rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBip44Wallet;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_ExtendedPrivateKey => wire.rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerExtendedPrivateKey;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_ExtendedPrivateKey => wire.rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerExtendedPrivateKey;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_ExtendedPublicKey => wire.rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerExtendedPublicKey;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_ExtendedPublicKey => wire.rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerExtendedPublicKey;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_Mnemonic => wire.rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMnemonic;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_Mnemonic => wire.rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMnemonic;



                  @protected Bip44Wallet dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBip44Wallet(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return Bip44WalletImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected ExtendedPrivateKey dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerExtendedPrivateKey(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return ExtendedPrivateKeyImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected ExtendedPublicKey dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerExtendedPublicKey(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return ExtendedPublicKeyImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected Mnemonic dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMnemonic(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return MnemonicImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected Bip44Wallet dco_decode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBip44Wallet(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return Bip44WalletImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected Bip44Wallet dco_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBip44Wallet(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return Bip44WalletImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected ExtendedPrivateKey dco_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerExtendedPrivateKey(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return ExtendedPrivateKeyImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected ExtendedPublicKey dco_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerExtendedPublicKey(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return ExtendedPublicKeyImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected Mnemonic dco_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMnemonic(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return MnemonicImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected Bip44Wallet dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBip44Wallet(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return Bip44WalletImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected ExtendedPrivateKey dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerExtendedPrivateKey(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return ExtendedPrivateKeyImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected ExtendedPublicKey dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerExtendedPublicKey(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return ExtendedPublicKeyImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected Mnemonic dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMnemonic(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return MnemonicImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected String dco_decode_String(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return raw as String; }

@protected Bip44Account dco_decode_bip_44_account(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
final arr = raw as List<dynamic>;
                if (arr.length != 5) throw Exception('unexpected arr length: expect 5 but see ${arr.length}');
                return Bip44Account(purpose: dco_decode_purpose_type(arr[0]),
coinType: dco_decode_coin_type(arr[1]),
accountIndex: dco_decode_u_32(arr[2]),
network: dco_decode_network_type(arr[3]),
accountKey: dco_decode_String(arr[4]),); }

@protected bool dco_decode_bool(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return raw as bool; }

@protected Bip44Account dco_decode_box_autoadd_bip_44_account(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return dco_decode_bip_44_account(raw); }

@protected CoinType dco_decode_box_autoadd_coin_type(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return dco_decode_coin_type(raw); }

@protected ChainType dco_decode_chain_type(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return ChainType.values[raw as int]; }

@protected CoinType dco_decode_coin_type(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
switch (raw[0]) {
                case 0: return CoinType_Bitcoin();
case 1: return CoinType_BitcoinTestnet();
case 2: return CoinType_Litecoin();
case 3: return CoinType_Dogecoin();
case 4: return CoinType_Ethereum();
case 5: return CoinType_Custom(dco_decode_u_32(raw[1]),);
                default: throw Exception("unreachable");
            } }

@protected int dco_decode_i_32(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return raw as int; }

@protected List<String> dco_decode_list_String(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return (raw as List<dynamic>).map(dco_decode_String).toList(); }

@protected List<int> dco_decode_list_prim_u_8_loose(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return raw as List<int>; }

@protected Uint8List dco_decode_list_prim_u_8_strict(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return raw as Uint8List; }

@protected NetworkType dco_decode_network_type(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return NetworkType.values[raw as int]; }

@protected String? dco_decode_opt_String(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return raw == null ? null : dco_decode_String(raw); }

@protected PurposeType dco_decode_purpose_type(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return PurposeType.values[raw as int]; }

@protected int dco_decode_u_32(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return raw as int; }

@protected int dco_decode_u_8(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return raw as int; }

@protected void dco_decode_unit(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return; }

@protected BigInt dco_decode_usize(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return dcoDecodeU64(raw); }

@protected WalletResult dco_decode_wallet_result(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
final arr = raw as List<dynamic>;
                if (arr.length != 3) throw Exception('unexpected arr length: expect 3 but see ${arr.length}');
                return WalletResult(success: dco_decode_bool(arr[0]),
message: dco_decode_String(arr[1]),
data: dco_decode_opt_String(arr[2]),); }

@protected Bip44Wallet sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBip44Wallet(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return Bip44WalletImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected ExtendedPrivateKey sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerExtendedPrivateKey(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return ExtendedPrivateKeyImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected ExtendedPublicKey sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerExtendedPublicKey(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return ExtendedPublicKeyImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected Mnemonic sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMnemonic(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return MnemonicImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected Bip44Wallet sse_decode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBip44Wallet(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return Bip44WalletImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected Bip44Wallet sse_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBip44Wallet(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return Bip44WalletImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected ExtendedPrivateKey sse_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerExtendedPrivateKey(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return ExtendedPrivateKeyImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected ExtendedPublicKey sse_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerExtendedPublicKey(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return ExtendedPublicKeyImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected Mnemonic sse_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMnemonic(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return MnemonicImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected Bip44Wallet sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBip44Wallet(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return Bip44WalletImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected ExtendedPrivateKey sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerExtendedPrivateKey(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return ExtendedPrivateKeyImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected ExtendedPublicKey sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerExtendedPublicKey(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return ExtendedPublicKeyImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected Mnemonic sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMnemonic(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return MnemonicImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected String sse_decode_String(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
var inner = sse_decode_list_prim_u_8_strict(deserializer);
        return utf8.decoder.convert(inner); }

@protected Bip44Account sse_decode_bip_44_account(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
var var_purpose = sse_decode_purpose_type(deserializer);
var var_coinType = sse_decode_coin_type(deserializer);
var var_accountIndex = sse_decode_u_32(deserializer);
var var_network = sse_decode_network_type(deserializer);
var var_accountKey = sse_decode_String(deserializer);
return Bip44Account(purpose: var_purpose, coinType: var_coinType, accountIndex: var_accountIndex, network: var_network, accountKey: var_accountKey); }

@protected bool sse_decode_bool(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return deserializer.buffer.getUint8() != 0; }

@protected Bip44Account sse_decode_box_autoadd_bip_44_account(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return (sse_decode_bip_44_account(deserializer)); }

@protected CoinType sse_decode_box_autoadd_coin_type(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return (sse_decode_coin_type(deserializer)); }

@protected ChainType sse_decode_chain_type(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
var inner = sse_decode_i_32(deserializer);
        return ChainType.values[inner]; }

@protected CoinType sse_decode_coin_type(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs

            var tag_ = sse_decode_i_32(deserializer);
            switch (tag_) { case 0: return CoinType_Bitcoin();case 1: return CoinType_BitcoinTestnet();case 2: return CoinType_Litecoin();case 3: return CoinType_Dogecoin();case 4: return CoinType_Ethereum();case 5: var var_field0 = sse_decode_u_32(deserializer);
return CoinType_Custom(var_field0); default: throw UnimplementedError(''); }
             }

@protected int sse_decode_i_32(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return deserializer.buffer.getInt32(); }

@protected List<String> sse_decode_list_String(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs

        var len_ = sse_decode_i_32(deserializer);
        var ans_ = <String>[];
        for (var idx_ = 0; idx_ < len_; ++idx_) { ans_.add(sse_decode_String(deserializer)); }
        return ans_;
         }

@protected List<int> sse_decode_list_prim_u_8_loose(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
var len_ = sse_decode_i_32(deserializer);
                return deserializer.buffer.getUint8List(len_); }

@protected Uint8List sse_decode_list_prim_u_8_strict(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
var len_ = sse_decode_i_32(deserializer);
                return deserializer.buffer.getUint8List(len_); }

@protected NetworkType sse_decode_network_type(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
var inner = sse_decode_i_32(deserializer);
        return NetworkType.values[inner]; }

@protected String? sse_decode_opt_String(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs

            if (sse_decode_bool(deserializer)) {
                return (sse_decode_String(deserializer));
            } else {
                return null;
            }
             }

@protected PurposeType sse_decode_purpose_type(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
var inner = sse_decode_i_32(deserializer);
        return PurposeType.values[inner]; }

@protected int sse_decode_u_32(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return deserializer.buffer.getUint32(); }

@protected int sse_decode_u_8(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return deserializer.buffer.getUint8(); }

@protected void sse_decode_unit(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
 }

@protected BigInt sse_decode_usize(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return deserializer.buffer.getBigUint64(); }

@protected WalletResult sse_decode_wallet_result(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
var var_success = sse_decode_bool(deserializer);
var var_message = sse_decode_String(deserializer);
var var_data = sse_decode_opt_String(deserializer);
return WalletResult(success: var_success, message: var_message, data: var_data); }

@protected void sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBip44Wallet(Bip44Wallet self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as Bip44WalletImpl).frbInternalSseEncode(move: true), serializer); }

@protected void sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerExtendedPrivateKey(ExtendedPrivateKey self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as ExtendedPrivateKeyImpl).frbInternalSseEncode(move: true), serializer); }

@protected void sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerExtendedPublicKey(ExtendedPublicKey self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as ExtendedPublicKeyImpl).frbInternalSseEncode(move: true), serializer); }

@protected void sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMnemonic(Mnemonic self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as MnemonicImpl).frbInternalSseEncode(move: true), serializer); }

@protected void sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBip44Wallet(Bip44Wallet self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as Bip44WalletImpl).frbInternalSseEncode(move: false), serializer); }

@protected void sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBip44Wallet(Bip44Wallet self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as Bip44WalletImpl).frbInternalSseEncode(move: false), serializer); }

@protected void sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerExtendedPrivateKey(ExtendedPrivateKey self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as ExtendedPrivateKeyImpl).frbInternalSseEncode(move: false), serializer); }

@protected void sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerExtendedPublicKey(ExtendedPublicKey self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as ExtendedPublicKeyImpl).frbInternalSseEncode(move: false), serializer); }

@protected void sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMnemonic(Mnemonic self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as MnemonicImpl).frbInternalSseEncode(move: false), serializer); }

@protected void sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBip44Wallet(Bip44Wallet self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as Bip44WalletImpl).frbInternalSseEncode(move: null), serializer); }

@protected void sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerExtendedPrivateKey(ExtendedPrivateKey self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as ExtendedPrivateKeyImpl).frbInternalSseEncode(move: null), serializer); }

@protected void sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerExtendedPublicKey(ExtendedPublicKey self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as ExtendedPublicKeyImpl).frbInternalSseEncode(move: null), serializer); }

@protected void sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMnemonic(Mnemonic self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as MnemonicImpl).frbInternalSseEncode(move: null), serializer); }

@protected void sse_encode_String(String self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_list_prim_u_8_strict(utf8.encoder.convert(self), serializer); }

@protected void sse_encode_bip_44_account(Bip44Account self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_purpose_type(self.purpose, serializer);
sse_encode_coin_type(self.coinType, serializer);
sse_encode_u_32(self.accountIndex, serializer);
sse_encode_network_type(self.network, serializer);
sse_encode_String(self.accountKey, serializer);
 }

@protected void sse_encode_bool(bool self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
serializer.buffer.putUint8(self ? 1 : 0); }

@protected void sse_encode_box_autoadd_bip_44_account(Bip44Account self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_bip_44_account(self, serializer); }

@protected void sse_encode_box_autoadd_coin_type(CoinType self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_coin_type(self, serializer); }

@protected void sse_encode_chain_type(ChainType self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_i_32(self.index, serializer); }

@protected void sse_encode_coin_type(CoinType self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
switch (self) { case CoinType_Bitcoin(): sse_encode_i_32(0, serializer); case CoinType_BitcoinTestnet(): sse_encode_i_32(1, serializer); case CoinType_Litecoin(): sse_encode_i_32(2, serializer); case CoinType_Dogecoin(): sse_encode_i_32(3, serializer); case CoinType_Ethereum(): sse_encode_i_32(4, serializer); case CoinType_Custom(field0: final field0): sse_encode_i_32(5, serializer); sse_encode_u_32(field0, serializer);
  } }

@protected void sse_encode_i_32(int self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
serializer.buffer.putInt32(self); }

@protected void sse_encode_list_String(List<String> self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_i_32(self.length, serializer);
        for (final item in self) { sse_encode_String(item, serializer); } }

@protected void sse_encode_list_prim_u_8_loose(List<int> self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_i_32(self.length, serializer);
                    serializer.buffer.putUint8List(self is Uint8List ? self : Uint8List.fromList(self)); }

@protected void sse_encode_list_prim_u_8_strict(Uint8List self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_i_32(self.length, serializer);
                    serializer.buffer.putUint8List(self); }

@protected void sse_encode_network_type(NetworkType self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_i_32(self.index, serializer); }

@protected void sse_encode_opt_String(String? self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs

                sse_encode_bool(self != null, serializer);
                if (self != null) {
                    sse_encode_String(self, serializer);
                }
                 }

@protected void sse_encode_purpose_type(PurposeType self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_i_32(self.index, serializer); }

@protected void sse_encode_u_32(int self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
serializer.buffer.putUint32(self); }

@protected void sse_encode_u_8(int self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
serializer.buffer.putUint8(self); }

@protected void sse_encode_unit(void self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
 }

@protected void sse_encode_usize(BigInt self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
serializer.buffer.putBigUint64(self); }

@protected void sse_encode_wallet_result(WalletResult self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_bool(self.success, serializer);
sse_encode_String(self.message, serializer);
sse_encode_opt_String(self.data, serializer);
 }
                }
                

            @sealed class Bip44WalletImpl extends RustOpaque implements Bip44Wallet {
                // Not to be used by end users
                Bip44WalletImpl.frbInternalDcoDecode(List<dynamic> wire):
                    super.frbInternalDcoDecode(wire, _kStaticData);

                // Not to be used by end users
                Bip44WalletImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative):
                    super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

                static final _kStaticData = RustArcStaticData(
                    rustArcIncrementStrongCount: RustLib.instance.api.rust_arc_increment_strong_count_Bip44Wallet,
                    rustArcDecrementStrongCount: RustLib.instance.api.rust_arc_decrement_strong_count_Bip44Wallet,
                    rustArcDecrementStrongCountPtr: RustLib.instance.api.rust_arc_decrement_strong_count_Bip44WalletPtr,
                );

                /// Get an account for a specific coin type
 Future<Bip44Account>  getAccount({required PurposeType purpose , required CoinType coinType , required int accountIndex })=>RustLib.instance.api.crateBridgeBip44WalletGetAccount(that: this, purpose: purpose, coinType: coinType, accountIndex: accountIndex);


/// Get the network this wallet operates on
 Future<NetworkType>  network()=>RustLib.instance.api.crateBridgeBip44WalletNetwork(that: this, );


            }
            @sealed class ExtendedPrivateKeyImpl extends RustOpaque implements ExtendedPrivateKey {
                // Not to be used by end users
                ExtendedPrivateKeyImpl.frbInternalDcoDecode(List<dynamic> wire):
                    super.frbInternalDcoDecode(wire, _kStaticData);

                // Not to be used by end users
                ExtendedPrivateKeyImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative):
                    super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

                static final _kStaticData = RustArcStaticData(
                    rustArcIncrementStrongCount: RustLib.instance.api.rust_arc_increment_strong_count_ExtendedPrivateKey,
                    rustArcDecrementStrongCount: RustLib.instance.api.rust_arc_decrement_strong_count_ExtendedPrivateKey,
                    rustArcDecrementStrongCountPtr: RustLib.instance.api.rust_arc_decrement_strong_count_ExtendedPrivateKeyPtr,
                );

                /// Get the child number index
 Future<int>  childNumberIndex()=>RustLib.instance.api.crateBridgeExtendedPrivateKeyChildNumberIndex(that: this, );


/// Get the depth in derivation tree (0 = master, 1 = level-1 child, etc.)
 Future<int>  depth()=>RustLib.instance.api.crateBridgeExtendedPrivateKeyDepth(that: this, );


/// Derive a single child key
 Future<ExtendedPrivateKey>  deriveChild({required int index , required bool hardened })=>RustLib.instance.api.crateBridgeExtendedPrivateKeyDeriveChild(that: this, index: index, hardened: hardened);


/// Derive using a path string (e.g., "m/44'/0'/0'/0/0")
 Future<ExtendedPrivateKey>  derivePath({required String path })=>RustLib.instance.api.crateBridgeExtendedPrivateKeyDerivePath(that: this, path: path);


/// Get this key's fingerprint (4 bytes)
 Future<Uint8List>  fingerprint()=>RustLib.instance.api.crateBridgeExtendedPrivateKeyFingerprint(that: this, );


/// Check if this is a hardened key
 Future<bool>  isHardened()=>RustLib.instance.api.crateBridgeExtendedPrivateKeyIsHardened(that: this, );


/// Get the network this key belongs to
 Future<NetworkType>  network()=>RustLib.instance.api.crateBridgeExtendedPrivateKeyNetwork(that: this, );


/// Get the parent fingerprint (4 bytes)
 Future<Uint8List>  parentFingerprint()=>RustLib.instance.api.crateBridgeExtendedPrivateKeyParentFingerprint(that: this, );


/// Convert to extended public key
 Future<ExtendedPublicKey>  toExtendedPublicKey()=>RustLib.instance.api.crateBridgeExtendedPrivateKeyToExtendedPublicKey(that: this, );


/// Serialize to extended key string (xprv... format)
 Future<String>  toExtendedString()=>RustLib.instance.api.crateBridgeExtendedPrivateKeyToExtendedString(that: this, );


            }
            @sealed class ExtendedPublicKeyImpl extends RustOpaque implements ExtendedPublicKey {
                // Not to be used by end users
                ExtendedPublicKeyImpl.frbInternalDcoDecode(List<dynamic> wire):
                    super.frbInternalDcoDecode(wire, _kStaticData);

                // Not to be used by end users
                ExtendedPublicKeyImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative):
                    super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

                static final _kStaticData = RustArcStaticData(
                    rustArcIncrementStrongCount: RustLib.instance.api.rust_arc_increment_strong_count_ExtendedPublicKey,
                    rustArcDecrementStrongCount: RustLib.instance.api.rust_arc_decrement_strong_count_ExtendedPublicKey,
                    rustArcDecrementStrongCountPtr: RustLib.instance.api.rust_arc_decrement_strong_count_ExtendedPublicKeyPtr,
                );

                /// Get the child number index
 Future<int>  childNumberIndex()=>RustLib.instance.api.crateBridgeExtendedPublicKeyChildNumberIndex(that: this, );


/// Get the depth in derivation tree
 Future<int>  depth()=>RustLib.instance.api.crateBridgeExtendedPublicKeyDepth(that: this, );


/// Derive a child public key (non-hardened only)
 Future<ExtendedPublicKey>  deriveChild({required int index })=>RustLib.instance.api.crateBridgeExtendedPublicKeyDeriveChild(that: this, index: index);


/// Derive using a path string (only non-hardened paths allowed)
 Future<ExtendedPublicKey>  derivePath({required String path })=>RustLib.instance.api.crateBridgeExtendedPublicKeyDerivePath(that: this, path: path);


/// Get this key's fingerprint (4 bytes)
 Future<Uint8List>  fingerprint()=>RustLib.instance.api.crateBridgeExtendedPublicKeyFingerprint(that: this, );


/// Check if this is a hardened key (public keys can only have non-hardened children)
 Future<bool>  isHardened()=>RustLib.instance.api.crateBridgeExtendedPublicKeyIsHardened(that: this, );


/// Get the network this key belongs to
 Future<NetworkType>  network()=>RustLib.instance.api.crateBridgeExtendedPublicKeyNetwork(that: this, );


/// Get the parent fingerprint (4 bytes)
 Future<Uint8List>  parentFingerprint()=>RustLib.instance.api.crateBridgeExtendedPublicKeyParentFingerprint(that: this, );


/// Serialize to extended key string (xpub... format)
 Future<String>  toExtendedString()=>RustLib.instance.api.crateBridgeExtendedPublicKeyToExtendedString(that: this, );


            }
            @sealed class MnemonicImpl extends RustOpaque implements Mnemonic {
                // Not to be used by end users
                MnemonicImpl.frbInternalDcoDecode(List<dynamic> wire):
                    super.frbInternalDcoDecode(wire, _kStaticData);

                // Not to be used by end users
                MnemonicImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative):
                    super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

                static final _kStaticData = RustArcStaticData(
                    rustArcIncrementStrongCount: RustLib.instance.api.rust_arc_increment_strong_count_Mnemonic,
                    rustArcDecrementStrongCount: RustLib.instance.api.rust_arc_decrement_strong_count_Mnemonic,
                    rustArcDecrementStrongCountPtr: RustLib.instance.api.rust_arc_decrement_strong_count_MnemonicPtr,
                );

                /// Validate that this mnemonic is valid (always true for constructed mnemonics)
 Future<bool>  isValid()=>RustLib.instance.api.crateBridgeMnemonicIsValid(that: this, );


/// Convert mnemonic to string phrase
 Future<String>  toPhrase()=>RustLib.instance.api.crateBridgeMnemonicToPhrase(that: this, );


/// Get the word count
 Future<int>  wordCount()=>RustLib.instance.api.crateBridgeMnemonicWordCount(that: this, );


            }