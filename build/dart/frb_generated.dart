// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: unused_import, unused_element, unnecessary_import, duplicate_ignore, invalid_use_of_internal_member, annotate_overrides, non_constant_identifier_names, curly_braces_in_flow_control_structures, prefer_const_literals_to_create_immutables, unused_field

import 'bridge.dart';
import 'dart:async';
import 'dart:convert';
import 'frb_generated.dart';
import 'frb_generated.io.dart'
    if (dart.library.js_interop) 'frb_generated.web.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

/// Main entrypoint of the Rust API
class RustLib extends BaseEntrypoint<RustLibApi, RustLibApiImpl, RustLibWire> {
  @internal
  static final instance = RustLib._();

  RustLib._();

  /// Initialize flutter_rust_bridge
  static Future<void> init({
    RustLibApi? api,
    BaseHandler? handler,
    ExternalLibrary? externalLibrary,
    bool forceSameCodegenVersion = true,
  }) async {
    await instance.initImpl(
      api: api,
      handler: handler,
      externalLibrary: externalLibrary,
      forceSameCodegenVersion: forceSameCodegenVersion,
    );
  }

  /// Initialize flutter_rust_bridge in mock mode.
  /// No libraries for FFI are loaded.
  static void initMock({
    required RustLibApi api,
  }) {
    instance.initMockImpl(
      api: api,
    );
  }

  /// Dispose flutter_rust_bridge
  ///
  /// The call to this function is optional, since flutter_rust_bridge (and everything else)
  /// is automatically disposed when the app stops.
  static void dispose() => instance.disposeImpl();

  @override
  ApiImplConstructor<RustLibApiImpl, RustLibWire> get apiImplConstructor =>
      RustLibApiImpl.new;

  @override
  WireConstructor<RustLibWire> get wireConstructor =>
      RustLibWire.fromExternalLibrary;

  @override
  Future<void> executeRustInitializers() async {}

  @override
  ExternalLibraryLoaderConfig get defaultExternalLibraryLoaderConfig =>
      kDefaultExternalLibraryLoaderConfig;

  @override
  String get codegenVersion => '2.11.1';

  @override
  int get rustContentHash => -1869164546;

  static const kDefaultExternalLibraryLoaderConfig =
      ExternalLibraryLoaderConfig(
    stem: 'khodpay_flutter_bridge',
    ioDirectory: '../../crates/flutter_bridge/target/release/',
    webPrefix: 'pkg/',
  );
}

abstract class RustLibApi extends BaseApi {
  Future<int> crateBridgeBip44AccountAccountIndex({required Bip44Account that});

  Future<CoinType> crateBridgeBip44AccountCoinType(
      {required Bip44Account that});

  Future<String> crateBridgeBip44AccountDeriveAddress(
      {required Bip44Account that, required Chain chain, required int index});

  Future<List<String>> crateBridgeBip44AccountDeriveAddressRange(
      {required Bip44Account that,
      required Chain chain,
      required int start,
      required int count});

  Future<String> crateBridgeBip44AccountDeriveExternal(
      {required Bip44Account that, required int index});

  Future<String> crateBridgeBip44AccountDeriveInternal(
      {required Bip44Account that, required int index});

  Future<String> crateBridgeBip44AccountExtendedKeyString(
      {required Bip44Account that});

  Future<Network> crateBridgeBip44AccountNetwork({required Bip44Account that});

  Future<Purpose> crateBridgeBip44AccountPurpose({required Bip44Account that});

  Future<Bip44Wallet> crateBridgeBip44WalletFromMnemonic(
      {required String mnemonic, String? passphrase, required Network network});

  Future<Bip44Wallet> crateBridgeBip44WalletFromSeed(
      {required List<int> seed, required Network network});

  Future<Bip44Account> crateBridgeBip44WalletGetAccount(
      {required Bip44Wallet that,
      required Purpose purpose,
      required CoinType coinType,
      required int accountIndex});

  Future<Network> crateBridgeBip44WalletNetwork({required Bip44Wallet that});

  Future<EvmAddress> crateBridgeEvmAddressFromBytes({required List<int> bytes});

  Future<EvmAddress> crateBridgeEvmAddressFromHex({required String hexString});

  Future<EvmAddress> crateBridgeEvmAddressFromPublicKey(
      {required List<int> pubkey});

  Future<bool> crateBridgeEvmAddressIsZero({required EvmAddress that});

  Future<Uint8List> crateBridgeEvmAddressToBytes({required EvmAddress that});

  Future<String> crateBridgeEvmAddressToChecksumString(
      {required EvmAddress that});

  Future<String> crateBridgeEvmAddressToHexString({required EvmAddress that});

  Future<bool> crateBridgeEvmAddressValidateChecksum({required String address});

  Future<EvmAddress> crateBridgeEvmAddressZero();

  Future<EvmAddress> crateBridgeEvmSignerAddress({required EvmSigner that});

  Future<String> crateBridgeEvmSignerAddressString({required EvmSigner that});

  Future<EvmSigner> crateBridgeEvmSignerFromAccount(
      {required Bip44Account account, required int addressIndex});

  Future<EvmSigner> crateBridgeEvmSignerFromPrivateKeyHex(
      {required String privateKeyHex});

  Future<SignedEvmTransaction> crateBridgeEvmSignerSignAndBuild(
      {required EvmSigner that, required Eip1559Transaction tx});

  Future<EvmSignature> crateBridgeEvmSignerSignHash(
      {required EvmSigner that, required List<int> hash});

  Future<EvmSignature> crateBridgeEvmSignerSignTransaction(
      {required EvmSigner that, required Eip1559Transaction tx});

  Future<int> crateBridgeExtendedPrivateKeyChildNumberIndex(
      {required ExtendedPrivateKey that});

  Future<int> crateBridgeExtendedPrivateKeyDepth(
      {required ExtendedPrivateKey that});

  Future<ExtendedPrivateKey> crateBridgeExtendedPrivateKeyDeriveChild(
      {required ExtendedPrivateKey that,
      required int index,
      required bool hardened});

  Future<ExtendedPrivateKey> crateBridgeExtendedPrivateKeyDerivePath(
      {required ExtendedPrivateKey that, required String path});

  Future<Uint8List> crateBridgeExtendedPrivateKeyFingerprint(
      {required ExtendedPrivateKey that});

  Future<ExtendedPrivateKey> crateBridgeExtendedPrivateKeyFromMnemonic(
      {required Mnemonic mnemonic,
      String? passphrase,
      required Network network});

  Future<ExtendedPrivateKey> crateBridgeExtendedPrivateKeyFromSeed(
      {required List<int> seed, required Network network});

  Future<ExtendedPrivateKey> crateBridgeExtendedPrivateKeyFromString(
      {required String s});

  Future<bool> crateBridgeExtendedPrivateKeyIsHardened(
      {required ExtendedPrivateKey that});

  Future<Network> crateBridgeExtendedPrivateKeyNetwork(
      {required ExtendedPrivateKey that});

  Future<Uint8List> crateBridgeExtendedPrivateKeyParentFingerprint(
      {required ExtendedPrivateKey that});

  Future<ExtendedPublicKey> crateBridgeExtendedPrivateKeyToExtendedPublicKey(
      {required ExtendedPrivateKey that});

  Future<String> crateBridgeExtendedPrivateKeyToExtendedString(
      {required ExtendedPrivateKey that});

  Future<int> crateBridgeExtendedPublicKeyChildNumberIndex(
      {required ExtendedPublicKey that});

  Future<int> crateBridgeExtendedPublicKeyDepth(
      {required ExtendedPublicKey that});

  Future<ExtendedPublicKey> crateBridgeExtendedPublicKeyDeriveChild(
      {required ExtendedPublicKey that, required int index});

  Future<ExtendedPublicKey> crateBridgeExtendedPublicKeyDerivePath(
      {required ExtendedPublicKey that, required String path});

  Future<Uint8List> crateBridgeExtendedPublicKeyFingerprint(
      {required ExtendedPublicKey that});

  Future<ExtendedPublicKey> crateBridgeExtendedPublicKeyFromString(
      {required String s});

  Future<bool> crateBridgeExtendedPublicKeyIsHardened(
      {required ExtendedPublicKey that});

  Future<Network> crateBridgeExtendedPublicKeyNetwork(
      {required ExtendedPublicKey that});

  Future<Uint8List> crateBridgeExtendedPublicKeyParentFingerprint(
      {required ExtendedPublicKey that});

  Future<String> crateBridgeExtendedPublicKeyToExtendedString(
      {required ExtendedPublicKey that});

  Future<Mnemonic> crateBridgeMnemonicFromPhrase({required String phrase});

  Future<Mnemonic> crateBridgeMnemonicGenerate({required int wordCount});

  Future<bool> crateBridgeMnemonicIsValid({required Mnemonic that});

  Future<String> crateBridgeMnemonicToPhrase({required Mnemonic that});

  Future<Uint8List> crateBridgeMnemonicToSeed(
      {required Mnemonic that, String? passphrase});

  Future<int> crateBridgeMnemonicWordCount({required Mnemonic that});

  Future<int> crateBridgeAdd({required int a, required int b});

  Future<BigInt> crateBridgeChainIdToU64({required ChainId chainId});

  Future<int> crateBridgeCoinTypeToIndex({required CoinType coinType});

  Future<String> crateBridgeCreateBip44Account(
      {required String mnemonic,
      String? passphrase,
      required Purpose purpose,
      required CoinType coinType,
      required int accountIndex,
      required Network network});

  Future<WalletResult> crateBridgeCreateBip44Wallet(
      {required String mnemonic,
      String? passphrase,
      required int accountIndex,
      required Network network});

  Future<String> crateBridgeCreateEvmSignerFromMnemonic(
      {required String mnemonic,
      String? passphrase,
      required int accountIndex,
      required int addressIndex});

  Future<String> crateBridgeCreateMasterKey(
      {required String mnemonic, String? passphrase, required Network network});

  Future<BigInt> crateBridgeCustomChainIdValue({required BigInt chainId});

  Future<String> crateBridgeDeriveBip44Address(
      {required String accountKey,
      required Chain chain,
      required int addressIndex});

  Future<String> crateBridgeDeriveEvmAddress(
      {required String extendedPrivateKey,
      required int chainIndex,
      required int addressIndex});

  Future<String> crateBridgeDeriveKey(
      {required String extendedKey, required String derivationPath});

  Future<Eip1559TransactionBuilder> crateBridgeEip1559TransactionBuilder();

  Future<Eip1559Transaction> crateBridgeEip1559TransactionBuilderBuild(
      {required Eip1559TransactionBuilder that});

  Future<Eip1559TransactionBuilder>
      crateBridgeEip1559TransactionBuilderDefault();

  Future<Eip1559TransactionBuilder> crateBridgeEip1559TransactionBuilderNew();

  Future<bool> crateBridgeEip1559TransactionIsContractCreation(
      {required Eip1559Transaction that});

  Future<bool> crateBridgeEip1559TransactionIsTransfer(
      {required Eip1559Transaction that});

  Future<BigInt> crateBridgeEip1559TransactionTokenTransferGas();

  Future<BigInt> crateBridgeEip1559TransactionTransferGas();

  Future<void> crateBridgeEip1559TransactionValidate(
      {required Eip1559Transaction that});

  Future<String> crateBridgeEtherToWei({required BigInt ether});

  Future<EvmAccessListItem> crateBridgeEvmAccessListItemAddressOnly(
      {required String address});

  Future<EvmAccessListItem> crateBridgeEvmAccessListItemNew(
      {required String address, required List<String> storageKeys});

  Future<EvmSignature> crateBridgeEvmSignatureFromBytes(
      {required List<int> bytes});

  Future<EvmSignature> crateBridgeEvmSignatureNew(
      {required String rHex, required String sHex, required int v});

  Future<Uint8List> crateBridgeEvmSignatureToBytes(
      {required EvmSignature that});

  Future<String> crateBridgeEvmSignatureToHexString(
      {required EvmSignature that});

  Future<EvmWei> crateBridgeEvmWeiAdd(
      {required EvmWei that, required EvmWei other});

  Future<EvmWei> crateBridgeEvmWeiFromEther({required BigInt ether});

  Future<EvmWei> crateBridgeEvmWeiFromGwei({required BigInt gwei});

  Future<EvmWei> crateBridgeEvmWeiFromWeiString({required String weiString});

  Future<EvmWei> crateBridgeEvmWeiFromWeiU64({required BigInt wei});

  Future<bool> crateBridgeEvmWeiIsZero({required EvmWei that});

  Future<EvmWei> crateBridgeEvmWeiMultiply(
      {required EvmWei that, required BigInt scalar});

  Future<String> crateBridgeEvmWeiToDecimalString({required EvmWei that});

  Future<BigInt> crateBridgeEvmWeiToEther({required EvmWei that});

  Future<BigInt> crateBridgeEvmWeiToGwei({required EvmWei that});

  Future<BigInt?> crateBridgeEvmWeiToU64({required EvmWei that});

  Future<EvmWei> crateBridgeEvmWeiZero();

  Future<String> crateBridgeGenerateMnemonic({required int wordCount});

  Future<String> crateBridgeGenerateMnemonicFromEntropy(
      {required List<int> entropy});

  Future<String> crateBridgeGetAddress(
      {required String extendedPrivateKey, required int addressIndex});

  Future<BigInt> crateBridgeGetChainIdValue({required ChainId chainId});

  Future<String> crateBridgeGetChainName({required ChainId chainId});

  Future<WalletResult> crateBridgeGetCoinInfo({required CoinType coinType});

  Future<BigInt> crateBridgeGetEtherInWei();

  Future<String> crateBridgeGetEvmAddressFromPrivateKey(
      {required String privateKeyHex});

  Future<BigInt> crateBridgeGetGweiInWei();

  Future<String> crateBridgeGetPublicKey({required String extendedPrivateKey});

  Future<WalletResult> crateBridgeGetPurposeInfo({required Purpose purpose});

  Future<BigInt> crateBridgeGetTokenTransferGas();

  Future<BigInt> crateBridgeGetTransferGas();

  Future<String> crateBridgeGweiToWei({required BigInt gwei});

  Future<String> crateBridgeHealthCheck();

  Future<bool> crateBridgeIsTestnetChain({required ChainId chainId});

  Future<String> crateBridgeMnemonicPhraseToSeedHex(
      {required String phrase, String? passphrase});

  Future<WalletResult> crateBridgeParseBip44Path({required String path});

  Future<String> crateBridgeParseEvmAddress({required String address});

  Future<String> crateBridgeRecoverSignerAddress(
      {required String hashHex, required String signatureHex});

  Future<String> crateBridgeSignEip1559Transaction(
      {required String privateKeyHex,
      required ChainId chainId,
      required BigInt nonce,
      required String to,
      required String valueWei,
      required BigInt gasLimit,
      required BigInt maxPriorityFeeGwei,
      required BigInt maxFeeGwei,
      String? dataHex});

  Future<Uint8List> crateBridgeSignedEvmTransactionEncode(
      {required SignedEvmTransaction that});

  Future<SignedEvmTransaction> crateBridgeSignedEvmTransactionNew(
      {required Eip1559Transaction transaction,
      required EvmSignature signature});

  Future<String> crateBridgeSignedEvmTransactionToRawTransaction(
      {required SignedEvmTransaction that});

  Future<Uint8List> crateBridgeSignedEvmTransactionTxHash(
      {required SignedEvmTransaction that});

  Future<String> crateBridgeSignedEvmTransactionTxHashHex(
      {required SignedEvmTransaction that});

  Future<bool> crateBridgeValidateEvmAddressChecksum({required String address});

  Future<bool> crateBridgeValidateMnemonic({required String phrase});

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_Bip44Account;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_Bip44Account;

  CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_Bip44AccountPtr;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_Bip44Wallet;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_Bip44Wallet;

  CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_Bip44WalletPtr;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_EvmAddress;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_EvmAddress;

  CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_EvmAddressPtr;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_EvmSigner;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_EvmSigner;

  CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_EvmSignerPtr;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_ExtendedPrivateKey;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_ExtendedPrivateKey;

  CrossPlatformFinalizerArg
      get rust_arc_decrement_strong_count_ExtendedPrivateKeyPtr;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_ExtendedPublicKey;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_ExtendedPublicKey;

  CrossPlatformFinalizerArg
      get rust_arc_decrement_strong_count_ExtendedPublicKeyPtr;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_Mnemonic;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_Mnemonic;

  CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_MnemonicPtr;
}

class RustLibApiImpl extends RustLibApiImplPlatform implements RustLibApi {
  RustLibApiImpl({
    required super.handler,
    required super.wire,
    required super.generalizedFrbRustBinding,
    required super.portManager,
  });

  @override
  Future<int> crateBridgeBip44AccountAccountIndex(
      {required Bip44Account that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBip44Account(
            that, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 1, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_u_32,
        decodeErrorData: null,
      ),
      constMeta: kCrateBridgeBip44AccountAccountIndexConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateBridgeBip44AccountAccountIndexConstMeta =>
      const TaskConstMeta(
        debugName: "Bip44Account_account_index",
        argNames: ["that"],
      );

  @override
  Future<CoinType> crateBridgeBip44AccountCoinType(
      {required Bip44Account that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBip44Account(
            that, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 2, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_coin_type,
        decodeErrorData: null,
      ),
      constMeta: kCrateBridgeBip44AccountCoinTypeConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateBridgeBip44AccountCoinTypeConstMeta =>
      const TaskConstMeta(
        debugName: "Bip44Account_coin_type",
        argNames: ["that"],
      );

  @override
  Future<String> crateBridgeBip44AccountDeriveAddress(
      {required Bip44Account that, required Chain chain, required int index}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBip44Account(
            that, serializer);
        sse_encode_chain(chain, serializer);
        sse_encode_u_32(index, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 3, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: sse_decode_String,
      ),
      constMeta: kCrateBridgeBip44AccountDeriveAddressConstMeta,
      argValues: [that, chain, index],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateBridgeBip44AccountDeriveAddressConstMeta =>
      const TaskConstMeta(
        debugName: "Bip44Account_derive_address",
        argNames: ["that", "chain", "index"],
      );

  @override
  Future<List<String>> crateBridgeBip44AccountDeriveAddressRange(
      {required Bip44Account that,
      required Chain chain,
      required int start,
      required int count}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBip44Account(
            that, serializer);
        sse_encode_chain(chain, serializer);
        sse_encode_u_32(start, serializer);
        sse_encode_u_32(count, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 4, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_list_String,
        decodeErrorData: sse_decode_String,
      ),
      constMeta: kCrateBridgeBip44AccountDeriveAddressRangeConstMeta,
      argValues: [that, chain, start, count],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateBridgeBip44AccountDeriveAddressRangeConstMeta =>
      const TaskConstMeta(
        debugName: "Bip44Account_derive_address_range",
        argNames: ["that", "chain", "start", "count"],
      );

  @override
  Future<String> crateBridgeBip44AccountDeriveExternal(
      {required Bip44Account that, required int index}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBip44Account(
            that, serializer);
        sse_encode_u_32(index, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 5, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: sse_decode_String,
      ),
      constMeta: kCrateBridgeBip44AccountDeriveExternalConstMeta,
      argValues: [that, index],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateBridgeBip44AccountDeriveExternalConstMeta =>
      const TaskConstMeta(
        debugName: "Bip44Account_derive_external",
        argNames: ["that", "index"],
      );

  @override
  Future<String> crateBridgeBip44AccountDeriveInternal(
      {required Bip44Account that, required int index}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBip44Account(
            that, serializer);
        sse_encode_u_32(index, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 6, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: sse_decode_String,
      ),
      constMeta: kCrateBridgeBip44AccountDeriveInternalConstMeta,
      argValues: [that, index],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateBridgeBip44AccountDeriveInternalConstMeta =>
      const TaskConstMeta(
        debugName: "Bip44Account_derive_internal",
        argNames: ["that", "index"],
      );

  @override
  Future<String> crateBridgeBip44AccountExtendedKeyString(
      {required Bip44Account that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBip44Account(
            that, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 7, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: null,
      ),
      constMeta: kCrateBridgeBip44AccountExtendedKeyStringConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateBridgeBip44AccountExtendedKeyStringConstMeta =>
      const TaskConstMeta(
        debugName: "Bip44Account_extended_key_string",
        argNames: ["that"],
      );

  @override
  Future<Network> crateBridgeBip44AccountNetwork({required Bip44Account that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBip44Account(
            that, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 8, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_network,
        decodeErrorData: null,
      ),
      constMeta: kCrateBridgeBip44AccountNetworkConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateBridgeBip44AccountNetworkConstMeta =>
      const TaskConstMeta(
        debugName: "Bip44Account_network",
        argNames: ["that"],
      );

  @override
  Future<Purpose> crateBridgeBip44AccountPurpose({required Bip44Account that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBip44Account(
            that, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 9, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_purpose,
        decodeErrorData: null,
      ),
      constMeta: kCrateBridgeBip44AccountPurposeConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateBridgeBip44AccountPurposeConstMeta =>
      const TaskConstMeta(
        debugName: "Bip44Account_purpose",
        argNames: ["that"],
      );

  @override
  Future<Bip44Wallet> crateBridgeBip44WalletFromMnemonic(
      {required String mnemonic,
      String? passphrase,
      required Network network}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(mnemonic, serializer);
        sse_encode_opt_String(passphrase, serializer);
        sse_encode_network(network, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 10, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBip44Wallet,
        decodeErrorData: sse_decode_String,
      ),
      constMeta: kCrateBridgeBip44WalletFromMnemonicConstMeta,
      argValues: [mnemonic, passphrase, network],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateBridgeBip44WalletFromMnemonicConstMeta =>
      const TaskConstMeta(
        debugName: "Bip44Wallet_from_mnemonic",
        argNames: ["mnemonic", "passphrase", "network"],
      );

  @override
  Future<Bip44Wallet> crateBridgeBip44WalletFromSeed(
      {required List<int> seed, required Network network}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_list_prim_u_8_loose(seed, serializer);
        sse_encode_network(network, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 11, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBip44Wallet,
        decodeErrorData: sse_decode_String,
      ),
      constMeta: kCrateBridgeBip44WalletFromSeedConstMeta,
      argValues: [seed, network],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateBridgeBip44WalletFromSeedConstMeta =>
      const TaskConstMeta(
        debugName: "Bip44Wallet_from_seed",
        argNames: ["seed", "network"],
      );

  @override
  Future<Bip44Account> crateBridgeBip44WalletGetAccount(
      {required Bip44Wallet that,
      required Purpose purpose,
      required CoinType coinType,
      required int accountIndex}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBip44Wallet(
            that, serializer);
        sse_encode_purpose(purpose, serializer);
        sse_encode_coin_type(coinType, serializer);
        sse_encode_u_32(accountIndex, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 12, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBip44Account,
        decodeErrorData: sse_decode_String,
      ),
      constMeta: kCrateBridgeBip44WalletGetAccountConstMeta,
      argValues: [that, purpose, coinType, accountIndex],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateBridgeBip44WalletGetAccountConstMeta =>
      const TaskConstMeta(
        debugName: "Bip44Wallet_get_account",
        argNames: ["that", "purpose", "coinType", "accountIndex"],
      );

  @override
  Future<Network> crateBridgeBip44WalletNetwork({required Bip44Wallet that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBip44Wallet(
            that, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 13, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_network,
        decodeErrorData: null,
      ),
      constMeta: kCrateBridgeBip44WalletNetworkConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateBridgeBip44WalletNetworkConstMeta =>
      const TaskConstMeta(
        debugName: "Bip44Wallet_network",
        argNames: ["that"],
      );

  @override
  Future<EvmAddress> crateBridgeEvmAddressFromBytes(
      {required List<int> bytes}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_list_prim_u_8_loose(bytes, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 14, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerEvmAddress,
        decodeErrorData: sse_decode_String,
      ),
      constMeta: kCrateBridgeEvmAddressFromBytesConstMeta,
      argValues: [bytes],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateBridgeEvmAddressFromBytesConstMeta =>
      const TaskConstMeta(
        debugName: "EvmAddress_from_bytes",
        argNames: ["bytes"],
      );

  @override
  Future<EvmAddress> crateBridgeEvmAddressFromHex({required String hexString}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(hexString, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 15, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerEvmAddress,
        decodeErrorData: sse_decode_String,
      ),
      constMeta: kCrateBridgeEvmAddressFromHexConstMeta,
      argValues: [hexString],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateBridgeEvmAddressFromHexConstMeta =>
      const TaskConstMeta(
        debugName: "EvmAddress_from_hex",
        argNames: ["hexString"],
      );

  @override
  Future<EvmAddress> crateBridgeEvmAddressFromPublicKey(
      {required List<int> pubkey}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_list_prim_u_8_loose(pubkey, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 16, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerEvmAddress,
        decodeErrorData: sse_decode_String,
      ),
      constMeta: kCrateBridgeEvmAddressFromPublicKeyConstMeta,
      argValues: [pubkey],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateBridgeEvmAddressFromPublicKeyConstMeta =>
      const TaskConstMeta(
        debugName: "EvmAddress_from_public_key",
        argNames: ["pubkey"],
      );

  @override
  Future<bool> crateBridgeEvmAddressIsZero({required EvmAddress that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerEvmAddress(
            that, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 17, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_bool,
        decodeErrorData: null,
      ),
      constMeta: kCrateBridgeEvmAddressIsZeroConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateBridgeEvmAddressIsZeroConstMeta =>
      const TaskConstMeta(
        debugName: "EvmAddress_is_zero",
        argNames: ["that"],
      );

  @override
  Future<Uint8List> crateBridgeEvmAddressToBytes({required EvmAddress that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerEvmAddress(
            that, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 18, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_list_prim_u_8_strict,
        decodeErrorData: null,
      ),
      constMeta: kCrateBridgeEvmAddressToBytesConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateBridgeEvmAddressToBytesConstMeta =>
      const TaskConstMeta(
        debugName: "EvmAddress_to_bytes",
        argNames: ["that"],
      );

  @override
  Future<String> crateBridgeEvmAddressToChecksumString(
      {required EvmAddress that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerEvmAddress(
            that, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 19, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: null,
      ),
      constMeta: kCrateBridgeEvmAddressToChecksumStringConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateBridgeEvmAddressToChecksumStringConstMeta =>
      const TaskConstMeta(
        debugName: "EvmAddress_to_checksum_string",
        argNames: ["that"],
      );

  @override
  Future<String> crateBridgeEvmAddressToHexString({required EvmAddress that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerEvmAddress(
            that, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 20, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: null,
      ),
      constMeta: kCrateBridgeEvmAddressToHexStringConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateBridgeEvmAddressToHexStringConstMeta =>
      const TaskConstMeta(
        debugName: "EvmAddress_to_hex_string",
        argNames: ["that"],
      );

  @override
  Future<bool> crateBridgeEvmAddressValidateChecksum(
      {required String address}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(address, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 21, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_bool,
        decodeErrorData: null,
      ),
      constMeta: kCrateBridgeEvmAddressValidateChecksumConstMeta,
      argValues: [address],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateBridgeEvmAddressValidateChecksumConstMeta =>
      const TaskConstMeta(
        debugName: "EvmAddress_validate_checksum",
        argNames: ["address"],
      );

  @override
  Future<EvmAddress> crateBridgeEvmAddressZero() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 22, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerEvmAddress,
        decodeErrorData: null,
      ),
      constMeta: kCrateBridgeEvmAddressZeroConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateBridgeEvmAddressZeroConstMeta => const TaskConstMeta(
        debugName: "EvmAddress_zero",
        argNames: [],
      );

  @override
  Future<EvmAddress> crateBridgeEvmSignerAddress({required EvmSigner that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerEvmSigner(
            that, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 23, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerEvmAddress,
        decodeErrorData: null,
      ),
      constMeta: kCrateBridgeEvmSignerAddressConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateBridgeEvmSignerAddressConstMeta =>
      const TaskConstMeta(
        debugName: "EvmSigner_address",
        argNames: ["that"],
      );

  @override
  Future<String> crateBridgeEvmSignerAddressString({required EvmSigner that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerEvmSigner(
            that, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 24, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: null,
      ),
      constMeta: kCrateBridgeEvmSignerAddressStringConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateBridgeEvmSignerAddressStringConstMeta =>
      const TaskConstMeta(
        debugName: "EvmSigner_address_string",
        argNames: ["that"],
      );

  @override
  Future<EvmSigner> crateBridgeEvmSignerFromAccount(
      {required Bip44Account account, required int addressIndex}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBip44Account(
            account, serializer);
        sse_encode_u_32(addressIndex, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 25, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerEvmSigner,
        decodeErrorData: sse_decode_String,
      ),
      constMeta: kCrateBridgeEvmSignerFromAccountConstMeta,
      argValues: [account, addressIndex],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateBridgeEvmSignerFromAccountConstMeta =>
      const TaskConstMeta(
        debugName: "EvmSigner_from_account",
        argNames: ["account", "addressIndex"],
      );

  @override
  Future<EvmSigner> crateBridgeEvmSignerFromPrivateKeyHex(
      {required String privateKeyHex}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(privateKeyHex, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 26, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerEvmSigner,
        decodeErrorData: sse_decode_String,
      ),
      constMeta: kCrateBridgeEvmSignerFromPrivateKeyHexConstMeta,
      argValues: [privateKeyHex],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateBridgeEvmSignerFromPrivateKeyHexConstMeta =>
      const TaskConstMeta(
        debugName: "EvmSigner_from_private_key_hex",
        argNames: ["privateKeyHex"],
      );

  @override
  Future<SignedEvmTransaction> crateBridgeEvmSignerSignAndBuild(
      {required EvmSigner that, required Eip1559Transaction tx}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerEvmSigner(
            that, serializer);
        sse_encode_box_autoadd_eip_1559_transaction(tx, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 27, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_signed_evm_transaction,
        decodeErrorData: sse_decode_String,
      ),
      constMeta: kCrateBridgeEvmSignerSignAndBuildConstMeta,
      argValues: [that, tx],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateBridgeEvmSignerSignAndBuildConstMeta =>
      const TaskConstMeta(
        debugName: "EvmSigner_sign_and_build",
        argNames: ["that", "tx"],
      );

  @override
  Future<EvmSignature> crateBridgeEvmSignerSignHash(
      {required EvmSigner that, required List<int> hash}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerEvmSigner(
            that, serializer);
        sse_encode_list_prim_u_8_loose(hash, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 28, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_evm_signature,
        decodeErrorData: sse_decode_String,
      ),
      constMeta: kCrateBridgeEvmSignerSignHashConstMeta,
      argValues: [that, hash],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateBridgeEvmSignerSignHashConstMeta =>
      const TaskConstMeta(
        debugName: "EvmSigner_sign_hash",
        argNames: ["that", "hash"],
      );

  @override
  Future<EvmSignature> crateBridgeEvmSignerSignTransaction(
      {required EvmSigner that, required Eip1559Transaction tx}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerEvmSigner(
            that, serializer);
        sse_encode_box_autoadd_eip_1559_transaction(tx, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 29, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_evm_signature,
        decodeErrorData: sse_decode_String,
      ),
      constMeta: kCrateBridgeEvmSignerSignTransactionConstMeta,
      argValues: [that, tx],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateBridgeEvmSignerSignTransactionConstMeta =>
      const TaskConstMeta(
        debugName: "EvmSigner_sign_transaction",
        argNames: ["that", "tx"],
      );

  @override
  Future<int> crateBridgeExtendedPrivateKeyChildNumberIndex(
      {required ExtendedPrivateKey that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerExtendedPrivateKey(
            that, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 30, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_u_32,
        decodeErrorData: null,
      ),
      constMeta: kCrateBridgeExtendedPrivateKeyChildNumberIndexConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateBridgeExtendedPrivateKeyChildNumberIndexConstMeta =>
      const TaskConstMeta(
        debugName: "ExtendedPrivateKey_child_number_index",
        argNames: ["that"],
      );

  @override
  Future<int> crateBridgeExtendedPrivateKeyDepth(
      {required ExtendedPrivateKey that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerExtendedPrivateKey(
            that, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 31, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_u_8,
        decodeErrorData: null,
      ),
      constMeta: kCrateBridgeExtendedPrivateKeyDepthConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateBridgeExtendedPrivateKeyDepthConstMeta =>
      const TaskConstMeta(
        debugName: "ExtendedPrivateKey_depth",
        argNames: ["that"],
      );

  @override
  Future<ExtendedPrivateKey> crateBridgeExtendedPrivateKeyDeriveChild(
      {required ExtendedPrivateKey that,
      required int index,
      required bool hardened}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerExtendedPrivateKey(
            that, serializer);
        sse_encode_u_32(index, serializer);
        sse_encode_bool(hardened, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 32, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerExtendedPrivateKey,
        decodeErrorData: sse_decode_String,
      ),
      constMeta: kCrateBridgeExtendedPrivateKeyDeriveChildConstMeta,
      argValues: [that, index, hardened],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateBridgeExtendedPrivateKeyDeriveChildConstMeta =>
      const TaskConstMeta(
        debugName: "ExtendedPrivateKey_derive_child",
        argNames: ["that", "index", "hardened"],
      );

  @override
  Future<ExtendedPrivateKey> crateBridgeExtendedPrivateKeyDerivePath(
      {required ExtendedPrivateKey that, required String path}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerExtendedPrivateKey(
            that, serializer);
        sse_encode_String(path, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 33, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerExtendedPrivateKey,
        decodeErrorData: sse_decode_String,
      ),
      constMeta: kCrateBridgeExtendedPrivateKeyDerivePathConstMeta,
      argValues: [that, path],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateBridgeExtendedPrivateKeyDerivePathConstMeta =>
      const TaskConstMeta(
        debugName: "ExtendedPrivateKey_derive_path",
        argNames: ["that", "path"],
      );

  @override
  Future<Uint8List> crateBridgeExtendedPrivateKeyFingerprint(
      {required ExtendedPrivateKey that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerExtendedPrivateKey(
            that, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 34, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_list_prim_u_8_strict,
        decodeErrorData: null,
      ),
      constMeta: kCrateBridgeExtendedPrivateKeyFingerprintConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateBridgeExtendedPrivateKeyFingerprintConstMeta =>
      const TaskConstMeta(
        debugName: "ExtendedPrivateKey_fingerprint",
        argNames: ["that"],
      );

  @override
  Future<ExtendedPrivateKey> crateBridgeExtendedPrivateKeyFromMnemonic(
      {required Mnemonic mnemonic,
      String? passphrase,
      required Network network}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMnemonic(
            mnemonic, serializer);
        sse_encode_opt_String(passphrase, serializer);
        sse_encode_network(network, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 35, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerExtendedPrivateKey,
        decodeErrorData: sse_decode_String,
      ),
      constMeta: kCrateBridgeExtendedPrivateKeyFromMnemonicConstMeta,
      argValues: [mnemonic, passphrase, network],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateBridgeExtendedPrivateKeyFromMnemonicConstMeta =>
      const TaskConstMeta(
        debugName: "ExtendedPrivateKey_from_mnemonic",
        argNames: ["mnemonic", "passphrase", "network"],
      );

  @override
  Future<ExtendedPrivateKey> crateBridgeExtendedPrivateKeyFromSeed(
      {required List<int> seed, required Network network}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_list_prim_u_8_loose(seed, serializer);
        sse_encode_network(network, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 36, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerExtendedPrivateKey,
        decodeErrorData: sse_decode_String,
      ),
      constMeta: kCrateBridgeExtendedPrivateKeyFromSeedConstMeta,
      argValues: [seed, network],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateBridgeExtendedPrivateKeyFromSeedConstMeta =>
      const TaskConstMeta(
        debugName: "ExtendedPrivateKey_from_seed",
        argNames: ["seed", "network"],
      );

  @override
  Future<ExtendedPrivateKey> crateBridgeExtendedPrivateKeyFromString(
      {required String s}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(s, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 37, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerExtendedPrivateKey,
        decodeErrorData: sse_decode_String,
      ),
      constMeta: kCrateBridgeExtendedPrivateKeyFromStringConstMeta,
      argValues: [s],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateBridgeExtendedPrivateKeyFromStringConstMeta =>
      const TaskConstMeta(
        debugName: "ExtendedPrivateKey_from_string",
        argNames: ["s"],
      );

  @override
  Future<bool> crateBridgeExtendedPrivateKeyIsHardened(
      {required ExtendedPrivateKey that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerExtendedPrivateKey(
            that, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 38, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_bool,
        decodeErrorData: null,
      ),
      constMeta: kCrateBridgeExtendedPrivateKeyIsHardenedConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateBridgeExtendedPrivateKeyIsHardenedConstMeta =>
      const TaskConstMeta(
        debugName: "ExtendedPrivateKey_is_hardened",
        argNames: ["that"],
      );

  @override
  Future<Network> crateBridgeExtendedPrivateKeyNetwork(
      {required ExtendedPrivateKey that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerExtendedPrivateKey(
            that, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 39, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_network,
        decodeErrorData: null,
      ),
      constMeta: kCrateBridgeExtendedPrivateKeyNetworkConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateBridgeExtendedPrivateKeyNetworkConstMeta =>
      const TaskConstMeta(
        debugName: "ExtendedPrivateKey_network",
        argNames: ["that"],
      );

  @override
  Future<Uint8List> crateBridgeExtendedPrivateKeyParentFingerprint(
      {required ExtendedPrivateKey that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerExtendedPrivateKey(
            that, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 40, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_list_prim_u_8_strict,
        decodeErrorData: null,
      ),
      constMeta: kCrateBridgeExtendedPrivateKeyParentFingerprintConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateBridgeExtendedPrivateKeyParentFingerprintConstMeta =>
      const TaskConstMeta(
        debugName: "ExtendedPrivateKey_parent_fingerprint",
        argNames: ["that"],
      );

  @override
  Future<ExtendedPublicKey> crateBridgeExtendedPrivateKeyToExtendedPublicKey(
      {required ExtendedPrivateKey that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerExtendedPrivateKey(
            that, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 41, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerExtendedPublicKey,
        decodeErrorData: null,
      ),
      constMeta: kCrateBridgeExtendedPrivateKeyToExtendedPublicKeyConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kCrateBridgeExtendedPrivateKeyToExtendedPublicKeyConstMeta =>
          const TaskConstMeta(
            debugName: "ExtendedPrivateKey_to_extended_public_key",
            argNames: ["that"],
          );

  @override
  Future<String> crateBridgeExtendedPrivateKeyToExtendedString(
      {required ExtendedPrivateKey that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerExtendedPrivateKey(
            that, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 42, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: null,
      ),
      constMeta: kCrateBridgeExtendedPrivateKeyToExtendedStringConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateBridgeExtendedPrivateKeyToExtendedStringConstMeta =>
      const TaskConstMeta(
        debugName: "ExtendedPrivateKey_to_extended_string",
        argNames: ["that"],
      );

  @override
  Future<int> crateBridgeExtendedPublicKeyChildNumberIndex(
      {required ExtendedPublicKey that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerExtendedPublicKey(
            that, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 43, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_u_32,
        decodeErrorData: null,
      ),
      constMeta: kCrateBridgeExtendedPublicKeyChildNumberIndexConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateBridgeExtendedPublicKeyChildNumberIndexConstMeta =>
      const TaskConstMeta(
        debugName: "ExtendedPublicKey_child_number_index",
        argNames: ["that"],
      );

  @override
  Future<int> crateBridgeExtendedPublicKeyDepth(
      {required ExtendedPublicKey that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerExtendedPublicKey(
            that, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 44, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_u_8,
        decodeErrorData: null,
      ),
      constMeta: kCrateBridgeExtendedPublicKeyDepthConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateBridgeExtendedPublicKeyDepthConstMeta =>
      const TaskConstMeta(
        debugName: "ExtendedPublicKey_depth",
        argNames: ["that"],
      );

  @override
  Future<ExtendedPublicKey> crateBridgeExtendedPublicKeyDeriveChild(
      {required ExtendedPublicKey that, required int index}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerExtendedPublicKey(
            that, serializer);
        sse_encode_u_32(index, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 45, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerExtendedPublicKey,
        decodeErrorData: sse_decode_String,
      ),
      constMeta: kCrateBridgeExtendedPublicKeyDeriveChildConstMeta,
      argValues: [that, index],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateBridgeExtendedPublicKeyDeriveChildConstMeta =>
      const TaskConstMeta(
        debugName: "ExtendedPublicKey_derive_child",
        argNames: ["that", "index"],
      );

  @override
  Future<ExtendedPublicKey> crateBridgeExtendedPublicKeyDerivePath(
      {required ExtendedPublicKey that, required String path}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerExtendedPublicKey(
            that, serializer);
        sse_encode_String(path, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 46, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerExtendedPublicKey,
        decodeErrorData: sse_decode_String,
      ),
      constMeta: kCrateBridgeExtendedPublicKeyDerivePathConstMeta,
      argValues: [that, path],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateBridgeExtendedPublicKeyDerivePathConstMeta =>
      const TaskConstMeta(
        debugName: "ExtendedPublicKey_derive_path",
        argNames: ["that", "path"],
      );

  @override
  Future<Uint8List> crateBridgeExtendedPublicKeyFingerprint(
      {required ExtendedPublicKey that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerExtendedPublicKey(
            that, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 47, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_list_prim_u_8_strict,
        decodeErrorData: null,
      ),
      constMeta: kCrateBridgeExtendedPublicKeyFingerprintConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateBridgeExtendedPublicKeyFingerprintConstMeta =>
      const TaskConstMeta(
        debugName: "ExtendedPublicKey_fingerprint",
        argNames: ["that"],
      );

  @override
  Future<ExtendedPublicKey> crateBridgeExtendedPublicKeyFromString(
      {required String s}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(s, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 48, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerExtendedPublicKey,
        decodeErrorData: sse_decode_String,
      ),
      constMeta: kCrateBridgeExtendedPublicKeyFromStringConstMeta,
      argValues: [s],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateBridgeExtendedPublicKeyFromStringConstMeta =>
      const TaskConstMeta(
        debugName: "ExtendedPublicKey_from_string",
        argNames: ["s"],
      );

  @override
  Future<bool> crateBridgeExtendedPublicKeyIsHardened(
      {required ExtendedPublicKey that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerExtendedPublicKey(
            that, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 49, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_bool,
        decodeErrorData: null,
      ),
      constMeta: kCrateBridgeExtendedPublicKeyIsHardenedConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateBridgeExtendedPublicKeyIsHardenedConstMeta =>
      const TaskConstMeta(
        debugName: "ExtendedPublicKey_is_hardened",
        argNames: ["that"],
      );

  @override
  Future<Network> crateBridgeExtendedPublicKeyNetwork(
      {required ExtendedPublicKey that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerExtendedPublicKey(
            that, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 50, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_network,
        decodeErrorData: null,
      ),
      constMeta: kCrateBridgeExtendedPublicKeyNetworkConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateBridgeExtendedPublicKeyNetworkConstMeta =>
      const TaskConstMeta(
        debugName: "ExtendedPublicKey_network",
        argNames: ["that"],
      );

  @override
  Future<Uint8List> crateBridgeExtendedPublicKeyParentFingerprint(
      {required ExtendedPublicKey that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerExtendedPublicKey(
            that, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 51, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_list_prim_u_8_strict,
        decodeErrorData: null,
      ),
      constMeta: kCrateBridgeExtendedPublicKeyParentFingerprintConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateBridgeExtendedPublicKeyParentFingerprintConstMeta =>
      const TaskConstMeta(
        debugName: "ExtendedPublicKey_parent_fingerprint",
        argNames: ["that"],
      );

  @override
  Future<String> crateBridgeExtendedPublicKeyToExtendedString(
      {required ExtendedPublicKey that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerExtendedPublicKey(
            that, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 52, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: null,
      ),
      constMeta: kCrateBridgeExtendedPublicKeyToExtendedStringConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateBridgeExtendedPublicKeyToExtendedStringConstMeta =>
      const TaskConstMeta(
        debugName: "ExtendedPublicKey_to_extended_string",
        argNames: ["that"],
      );

  @override
  Future<Mnemonic> crateBridgeMnemonicFromPhrase({required String phrase}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(phrase, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 53, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMnemonic,
        decodeErrorData: sse_decode_String,
      ),
      constMeta: kCrateBridgeMnemonicFromPhraseConstMeta,
      argValues: [phrase],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateBridgeMnemonicFromPhraseConstMeta =>
      const TaskConstMeta(
        debugName: "Mnemonic_from_phrase",
        argNames: ["phrase"],
      );

  @override
  Future<Mnemonic> crateBridgeMnemonicGenerate({required int wordCount}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_u_32(wordCount, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 54, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMnemonic,
        decodeErrorData: sse_decode_String,
      ),
      constMeta: kCrateBridgeMnemonicGenerateConstMeta,
      argValues: [wordCount],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateBridgeMnemonicGenerateConstMeta =>
      const TaskConstMeta(
        debugName: "Mnemonic_generate",
        argNames: ["wordCount"],
      );

  @override
  Future<bool> crateBridgeMnemonicIsValid({required Mnemonic that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMnemonic(
            that, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 55, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_bool,
        decodeErrorData: null,
      ),
      constMeta: kCrateBridgeMnemonicIsValidConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateBridgeMnemonicIsValidConstMeta => const TaskConstMeta(
        debugName: "Mnemonic_is_valid",
        argNames: ["that"],
      );

  @override
  Future<String> crateBridgeMnemonicToPhrase({required Mnemonic that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMnemonic(
            that, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 56, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: null,
      ),
      constMeta: kCrateBridgeMnemonicToPhraseConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateBridgeMnemonicToPhraseConstMeta =>
      const TaskConstMeta(
        debugName: "Mnemonic_to_phrase",
        argNames: ["that"],
      );

  @override
  Future<Uint8List> crateBridgeMnemonicToSeed(
      {required Mnemonic that, String? passphrase}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMnemonic(
            that, serializer);
        sse_encode_opt_String(passphrase, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 57, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_list_prim_u_8_strict,
        decodeErrorData: sse_decode_String,
      ),
      constMeta: kCrateBridgeMnemonicToSeedConstMeta,
      argValues: [that, passphrase],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateBridgeMnemonicToSeedConstMeta => const TaskConstMeta(
        debugName: "Mnemonic_to_seed",
        argNames: ["that", "passphrase"],
      );

  @override
  Future<int> crateBridgeMnemonicWordCount({required Mnemonic that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMnemonic(
            that, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 58, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_u_32,
        decodeErrorData: null,
      ),
      constMeta: kCrateBridgeMnemonicWordCountConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateBridgeMnemonicWordCountConstMeta =>
      const TaskConstMeta(
        debugName: "Mnemonic_word_count",
        argNames: ["that"],
      );

  @override
  Future<int> crateBridgeAdd({required int a, required int b}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_i_32(a, serializer);
        sse_encode_i_32(b, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 59, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_i_32,
        decodeErrorData: null,
      ),
      constMeta: kCrateBridgeAddConstMeta,
      argValues: [a, b],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateBridgeAddConstMeta => const TaskConstMeta(
        debugName: "add",
        argNames: ["a", "b"],
      );

  @override
  Future<BigInt> crateBridgeChainIdToU64({required ChainId chainId}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_chain_id(chainId, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 60, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_u_64,
        decodeErrorData: null,
      ),
      constMeta: kCrateBridgeChainIdToU64ConstMeta,
      argValues: [chainId],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateBridgeChainIdToU64ConstMeta => const TaskConstMeta(
        debugName: "chain_id_to_u64",
        argNames: ["chainId"],
      );

  @override
  Future<int> crateBridgeCoinTypeToIndex({required CoinType coinType}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_coin_type(coinType, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 61, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_u_32,
        decodeErrorData: null,
      ),
      constMeta: kCrateBridgeCoinTypeToIndexConstMeta,
      argValues: [coinType],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateBridgeCoinTypeToIndexConstMeta => const TaskConstMeta(
        debugName: "coin_type_to_index",
        argNames: ["coinType"],
      );

  @override
  Future<String> crateBridgeCreateBip44Account(
      {required String mnemonic,
      String? passphrase,
      required Purpose purpose,
      required CoinType coinType,
      required int accountIndex,
      required Network network}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(mnemonic, serializer);
        sse_encode_opt_String(passphrase, serializer);
        sse_encode_purpose(purpose, serializer);
        sse_encode_coin_type(coinType, serializer);
        sse_encode_u_32(accountIndex, serializer);
        sse_encode_network(network, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 62, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: sse_decode_String,
      ),
      constMeta: kCrateBridgeCreateBip44AccountConstMeta,
      argValues: [
        mnemonic,
        passphrase,
        purpose,
        coinType,
        accountIndex,
        network
      ],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateBridgeCreateBip44AccountConstMeta =>
      const TaskConstMeta(
        debugName: "create_bip44_account",
        argNames: [
          "mnemonic",
          "passphrase",
          "purpose",
          "coinType",
          "accountIndex",
          "network"
        ],
      );

  @override
  Future<WalletResult> crateBridgeCreateBip44Wallet(
      {required String mnemonic,
      String? passphrase,
      required int accountIndex,
      required Network network}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(mnemonic, serializer);
        sse_encode_opt_String(passphrase, serializer);
        sse_encode_u_32(accountIndex, serializer);
        sse_encode_network(network, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 63, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_wallet_result,
        decodeErrorData: sse_decode_String,
      ),
      constMeta: kCrateBridgeCreateBip44WalletConstMeta,
      argValues: [mnemonic, passphrase, accountIndex, network],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateBridgeCreateBip44WalletConstMeta =>
      const TaskConstMeta(
        debugName: "create_bip44_wallet",
        argNames: ["mnemonic", "passphrase", "accountIndex", "network"],
      );

  @override
  Future<String> crateBridgeCreateEvmSignerFromMnemonic(
      {required String mnemonic,
      String? passphrase,
      required int accountIndex,
      required int addressIndex}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(mnemonic, serializer);
        sse_encode_opt_String(passphrase, serializer);
        sse_encode_u_32(accountIndex, serializer);
        sse_encode_u_32(addressIndex, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 64, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: sse_decode_String,
      ),
      constMeta: kCrateBridgeCreateEvmSignerFromMnemonicConstMeta,
      argValues: [mnemonic, passphrase, accountIndex, addressIndex],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateBridgeCreateEvmSignerFromMnemonicConstMeta =>
      const TaskConstMeta(
        debugName: "create_evm_signer_from_mnemonic",
        argNames: ["mnemonic", "passphrase", "accountIndex", "addressIndex"],
      );

  @override
  Future<String> crateBridgeCreateMasterKey(
      {required String mnemonic,
      String? passphrase,
      required Network network}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(mnemonic, serializer);
        sse_encode_opt_String(passphrase, serializer);
        sse_encode_network(network, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 65, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: sse_decode_String,
      ),
      constMeta: kCrateBridgeCreateMasterKeyConstMeta,
      argValues: [mnemonic, passphrase, network],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateBridgeCreateMasterKeyConstMeta => const TaskConstMeta(
        debugName: "create_master_key",
        argNames: ["mnemonic", "passphrase", "network"],
      );

  @override
  Future<BigInt> crateBridgeCustomChainIdValue({required BigInt chainId}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_u_64(chainId, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 66, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_u_64,
        decodeErrorData: null,
      ),
      constMeta: kCrateBridgeCustomChainIdValueConstMeta,
      argValues: [chainId],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateBridgeCustomChainIdValueConstMeta =>
      const TaskConstMeta(
        debugName: "custom_chain_id_value",
        argNames: ["chainId"],
      );

  @override
  Future<String> crateBridgeDeriveBip44Address(
      {required String accountKey,
      required Chain chain,
      required int addressIndex}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(accountKey, serializer);
        sse_encode_chain(chain, serializer);
        sse_encode_u_32(addressIndex, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 67, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: sse_decode_String,
      ),
      constMeta: kCrateBridgeDeriveBip44AddressConstMeta,
      argValues: [accountKey, chain, addressIndex],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateBridgeDeriveBip44AddressConstMeta =>
      const TaskConstMeta(
        debugName: "derive_bip44_address",
        argNames: ["accountKey", "chain", "addressIndex"],
      );

  @override
  Future<String> crateBridgeDeriveEvmAddress(
      {required String extendedPrivateKey,
      required int chainIndex,
      required int addressIndex}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(extendedPrivateKey, serializer);
        sse_encode_u_32(chainIndex, serializer);
        sse_encode_u_32(addressIndex, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 68, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: sse_decode_String,
      ),
      constMeta: kCrateBridgeDeriveEvmAddressConstMeta,
      argValues: [extendedPrivateKey, chainIndex, addressIndex],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateBridgeDeriveEvmAddressConstMeta =>
      const TaskConstMeta(
        debugName: "derive_evm_address",
        argNames: ["extendedPrivateKey", "chainIndex", "addressIndex"],
      );

  @override
  Future<String> crateBridgeDeriveKey(
      {required String extendedKey, required String derivationPath}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(extendedKey, serializer);
        sse_encode_String(derivationPath, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 69, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: sse_decode_String,
      ),
      constMeta: kCrateBridgeDeriveKeyConstMeta,
      argValues: [extendedKey, derivationPath],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateBridgeDeriveKeyConstMeta => const TaskConstMeta(
        debugName: "derive_key",
        argNames: ["extendedKey", "derivationPath"],
      );

  @override
  Future<Eip1559TransactionBuilder> crateBridgeEip1559TransactionBuilder() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 70, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_eip_1559_transaction_builder,
        decodeErrorData: null,
      ),
      constMeta: kCrateBridgeEip1559TransactionBuilderConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateBridgeEip1559TransactionBuilderConstMeta =>
      const TaskConstMeta(
        debugName: "eip_1559_transaction_builder",
        argNames: [],
      );

  @override
  Future<Eip1559Transaction> crateBridgeEip1559TransactionBuilderBuild(
      {required Eip1559TransactionBuilder that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_box_autoadd_eip_1559_transaction_builder(that, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 71, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_eip_1559_transaction,
        decodeErrorData: sse_decode_String,
      ),
      constMeta: kCrateBridgeEip1559TransactionBuilderBuildConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateBridgeEip1559TransactionBuilderBuildConstMeta =>
      const TaskConstMeta(
        debugName: "eip_1559_transaction_builder_build",
        argNames: ["that"],
      );

  @override
  Future<Eip1559TransactionBuilder>
      crateBridgeEip1559TransactionBuilderDefault() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 72, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_eip_1559_transaction_builder,
        decodeErrorData: null,
      ),
      constMeta: kCrateBridgeEip1559TransactionBuilderDefaultConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateBridgeEip1559TransactionBuilderDefaultConstMeta =>
      const TaskConstMeta(
        debugName: "eip_1559_transaction_builder_default",
        argNames: [],
      );

  @override
  Future<Eip1559TransactionBuilder> crateBridgeEip1559TransactionBuilderNew() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 73, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_eip_1559_transaction_builder,
        decodeErrorData: null,
      ),
      constMeta: kCrateBridgeEip1559TransactionBuilderNewConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateBridgeEip1559TransactionBuilderNewConstMeta =>
      const TaskConstMeta(
        debugName: "eip_1559_transaction_builder_new",
        argNames: [],
      );

  @override
  Future<bool> crateBridgeEip1559TransactionIsContractCreation(
      {required Eip1559Transaction that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_box_autoadd_eip_1559_transaction(that, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 74, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_bool,
        decodeErrorData: null,
      ),
      constMeta: kCrateBridgeEip1559TransactionIsContractCreationConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateBridgeEip1559TransactionIsContractCreationConstMeta =>
      const TaskConstMeta(
        debugName: "eip_1559_transaction_is_contract_creation",
        argNames: ["that"],
      );

  @override
  Future<bool> crateBridgeEip1559TransactionIsTransfer(
      {required Eip1559Transaction that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_box_autoadd_eip_1559_transaction(that, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 75, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_bool,
        decodeErrorData: null,
      ),
      constMeta: kCrateBridgeEip1559TransactionIsTransferConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateBridgeEip1559TransactionIsTransferConstMeta =>
      const TaskConstMeta(
        debugName: "eip_1559_transaction_is_transfer",
        argNames: ["that"],
      );

  @override
  Future<BigInt> crateBridgeEip1559TransactionTokenTransferGas() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 76, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_u_64,
        decodeErrorData: null,
      ),
      constMeta: kCrateBridgeEip1559TransactionTokenTransferGasConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateBridgeEip1559TransactionTokenTransferGasConstMeta =>
      const TaskConstMeta(
        debugName: "eip_1559_transaction_token_transfer_gas",
        argNames: [],
      );

  @override
  Future<BigInt> crateBridgeEip1559TransactionTransferGas() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 77, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_u_64,
        decodeErrorData: null,
      ),
      constMeta: kCrateBridgeEip1559TransactionTransferGasConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateBridgeEip1559TransactionTransferGasConstMeta =>
      const TaskConstMeta(
        debugName: "eip_1559_transaction_transfer_gas",
        argNames: [],
      );

  @override
  Future<void> crateBridgeEip1559TransactionValidate(
      {required Eip1559Transaction that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_box_autoadd_eip_1559_transaction(that, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 78, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_String,
      ),
      constMeta: kCrateBridgeEip1559TransactionValidateConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateBridgeEip1559TransactionValidateConstMeta =>
      const TaskConstMeta(
        debugName: "eip_1559_transaction_validate",
        argNames: ["that"],
      );

  @override
  Future<String> crateBridgeEtherToWei({required BigInt ether}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_u_64(ether, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 79, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: null,
      ),
      constMeta: kCrateBridgeEtherToWeiConstMeta,
      argValues: [ether],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateBridgeEtherToWeiConstMeta => const TaskConstMeta(
        debugName: "ether_to_wei",
        argNames: ["ether"],
      );

  @override
  Future<EvmAccessListItem> crateBridgeEvmAccessListItemAddressOnly(
      {required String address}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(address, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 80, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_evm_access_list_item,
        decodeErrorData: null,
      ),
      constMeta: kCrateBridgeEvmAccessListItemAddressOnlyConstMeta,
      argValues: [address],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateBridgeEvmAccessListItemAddressOnlyConstMeta =>
      const TaskConstMeta(
        debugName: "evm_access_list_item_address_only",
        argNames: ["address"],
      );

  @override
  Future<EvmAccessListItem> crateBridgeEvmAccessListItemNew(
      {required String address, required List<String> storageKeys}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(address, serializer);
        sse_encode_list_String(storageKeys, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 81, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_evm_access_list_item,
        decodeErrorData: null,
      ),
      constMeta: kCrateBridgeEvmAccessListItemNewConstMeta,
      argValues: [address, storageKeys],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateBridgeEvmAccessListItemNewConstMeta =>
      const TaskConstMeta(
        debugName: "evm_access_list_item_new",
        argNames: ["address", "storageKeys"],
      );

  @override
  Future<EvmSignature> crateBridgeEvmSignatureFromBytes(
      {required List<int> bytes}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_list_prim_u_8_loose(bytes, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 82, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_evm_signature,
        decodeErrorData: sse_decode_String,
      ),
      constMeta: kCrateBridgeEvmSignatureFromBytesConstMeta,
      argValues: [bytes],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateBridgeEvmSignatureFromBytesConstMeta =>
      const TaskConstMeta(
        debugName: "evm_signature_from_bytes",
        argNames: ["bytes"],
      );

  @override
  Future<EvmSignature> crateBridgeEvmSignatureNew(
      {required String rHex, required String sHex, required int v}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(rHex, serializer);
        sse_encode_String(sHex, serializer);
        sse_encode_u_8(v, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 83, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_evm_signature,
        decodeErrorData: null,
      ),
      constMeta: kCrateBridgeEvmSignatureNewConstMeta,
      argValues: [rHex, sHex, v],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateBridgeEvmSignatureNewConstMeta => const TaskConstMeta(
        debugName: "evm_signature_new",
        argNames: ["rHex", "sHex", "v"],
      );

  @override
  Future<Uint8List> crateBridgeEvmSignatureToBytes(
      {required EvmSignature that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_box_autoadd_evm_signature(that, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 84, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_list_prim_u_8_strict,
        decodeErrorData: sse_decode_String,
      ),
      constMeta: kCrateBridgeEvmSignatureToBytesConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateBridgeEvmSignatureToBytesConstMeta =>
      const TaskConstMeta(
        debugName: "evm_signature_to_bytes",
        argNames: ["that"],
      );

  @override
  Future<String> crateBridgeEvmSignatureToHexString(
      {required EvmSignature that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_box_autoadd_evm_signature(that, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 85, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: null,
      ),
      constMeta: kCrateBridgeEvmSignatureToHexStringConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateBridgeEvmSignatureToHexStringConstMeta =>
      const TaskConstMeta(
        debugName: "evm_signature_to_hex_string",
        argNames: ["that"],
      );

  @override
  Future<EvmWei> crateBridgeEvmWeiAdd(
      {required EvmWei that, required EvmWei other}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_box_autoadd_evm_wei(that, serializer);
        sse_encode_box_autoadd_evm_wei(other, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 86, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_evm_wei,
        decodeErrorData: sse_decode_String,
      ),
      constMeta: kCrateBridgeEvmWeiAddConstMeta,
      argValues: [that, other],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateBridgeEvmWeiAddConstMeta => const TaskConstMeta(
        debugName: "evm_wei_add",
        argNames: ["that", "other"],
      );

  @override
  Future<EvmWei> crateBridgeEvmWeiFromEther({required BigInt ether}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_u_64(ether, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 87, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_evm_wei,
        decodeErrorData: null,
      ),
      constMeta: kCrateBridgeEvmWeiFromEtherConstMeta,
      argValues: [ether],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateBridgeEvmWeiFromEtherConstMeta => const TaskConstMeta(
        debugName: "evm_wei_from_ether",
        argNames: ["ether"],
      );

  @override
  Future<EvmWei> crateBridgeEvmWeiFromGwei({required BigInt gwei}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_u_64(gwei, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 88, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_evm_wei,
        decodeErrorData: null,
      ),
      constMeta: kCrateBridgeEvmWeiFromGweiConstMeta,
      argValues: [gwei],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateBridgeEvmWeiFromGweiConstMeta => const TaskConstMeta(
        debugName: "evm_wei_from_gwei",
        argNames: ["gwei"],
      );

  @override
  Future<EvmWei> crateBridgeEvmWeiFromWeiString({required String weiString}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(weiString, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 89, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_evm_wei,
        decodeErrorData: sse_decode_String,
      ),
      constMeta: kCrateBridgeEvmWeiFromWeiStringConstMeta,
      argValues: [weiString],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateBridgeEvmWeiFromWeiStringConstMeta =>
      const TaskConstMeta(
        debugName: "evm_wei_from_wei_string",
        argNames: ["weiString"],
      );

  @override
  Future<EvmWei> crateBridgeEvmWeiFromWeiU64({required BigInt wei}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_u_64(wei, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 90, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_evm_wei,
        decodeErrorData: null,
      ),
      constMeta: kCrateBridgeEvmWeiFromWeiU64ConstMeta,
      argValues: [wei],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateBridgeEvmWeiFromWeiU64ConstMeta =>
      const TaskConstMeta(
        debugName: "evm_wei_from_wei_u64",
        argNames: ["wei"],
      );

  @override
  Future<bool> crateBridgeEvmWeiIsZero({required EvmWei that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_box_autoadd_evm_wei(that, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 91, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_bool,
        decodeErrorData: null,
      ),
      constMeta: kCrateBridgeEvmWeiIsZeroConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateBridgeEvmWeiIsZeroConstMeta => const TaskConstMeta(
        debugName: "evm_wei_is_zero",
        argNames: ["that"],
      );

  @override
  Future<EvmWei> crateBridgeEvmWeiMultiply(
      {required EvmWei that, required BigInt scalar}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_box_autoadd_evm_wei(that, serializer);
        sse_encode_u_64(scalar, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 92, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_evm_wei,
        decodeErrorData: sse_decode_String,
      ),
      constMeta: kCrateBridgeEvmWeiMultiplyConstMeta,
      argValues: [that, scalar],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateBridgeEvmWeiMultiplyConstMeta => const TaskConstMeta(
        debugName: "evm_wei_multiply",
        argNames: ["that", "scalar"],
      );

  @override
  Future<String> crateBridgeEvmWeiToDecimalString({required EvmWei that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_box_autoadd_evm_wei(that, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 93, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: null,
      ),
      constMeta: kCrateBridgeEvmWeiToDecimalStringConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateBridgeEvmWeiToDecimalStringConstMeta =>
      const TaskConstMeta(
        debugName: "evm_wei_to_decimal_string",
        argNames: ["that"],
      );

  @override
  Future<BigInt> crateBridgeEvmWeiToEther({required EvmWei that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_box_autoadd_evm_wei(that, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 94, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_u_64,
        decodeErrorData: null,
      ),
      constMeta: kCrateBridgeEvmWeiToEtherConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateBridgeEvmWeiToEtherConstMeta => const TaskConstMeta(
        debugName: "evm_wei_to_ether",
        argNames: ["that"],
      );

  @override
  Future<BigInt> crateBridgeEvmWeiToGwei({required EvmWei that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_box_autoadd_evm_wei(that, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 95, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_u_64,
        decodeErrorData: null,
      ),
      constMeta: kCrateBridgeEvmWeiToGweiConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateBridgeEvmWeiToGweiConstMeta => const TaskConstMeta(
        debugName: "evm_wei_to_gwei",
        argNames: ["that"],
      );

  @override
  Future<BigInt?> crateBridgeEvmWeiToU64({required EvmWei that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_box_autoadd_evm_wei(that, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 96, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_opt_box_autoadd_u_64,
        decodeErrorData: null,
      ),
      constMeta: kCrateBridgeEvmWeiToU64ConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateBridgeEvmWeiToU64ConstMeta => const TaskConstMeta(
        debugName: "evm_wei_to_u64",
        argNames: ["that"],
      );

  @override
  Future<EvmWei> crateBridgeEvmWeiZero() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 97, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_evm_wei,
        decodeErrorData: null,
      ),
      constMeta: kCrateBridgeEvmWeiZeroConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateBridgeEvmWeiZeroConstMeta => const TaskConstMeta(
        debugName: "evm_wei_zero",
        argNames: [],
      );

  @override
  Future<String> crateBridgeGenerateMnemonic({required int wordCount}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_u_32(wordCount, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 98, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: sse_decode_String,
      ),
      constMeta: kCrateBridgeGenerateMnemonicConstMeta,
      argValues: [wordCount],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateBridgeGenerateMnemonicConstMeta =>
      const TaskConstMeta(
        debugName: "generate_mnemonic",
        argNames: ["wordCount"],
      );

  @override
  Future<String> crateBridgeGenerateMnemonicFromEntropy(
      {required List<int> entropy}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_list_prim_u_8_loose(entropy, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 99, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: sse_decode_String,
      ),
      constMeta: kCrateBridgeGenerateMnemonicFromEntropyConstMeta,
      argValues: [entropy],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateBridgeGenerateMnemonicFromEntropyConstMeta =>
      const TaskConstMeta(
        debugName: "generate_mnemonic_from_entropy",
        argNames: ["entropy"],
      );

  @override
  Future<String> crateBridgeGetAddress(
      {required String extendedPrivateKey, required int addressIndex}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(extendedPrivateKey, serializer);
        sse_encode_u_32(addressIndex, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 100, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: sse_decode_String,
      ),
      constMeta: kCrateBridgeGetAddressConstMeta,
      argValues: [extendedPrivateKey, addressIndex],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateBridgeGetAddressConstMeta => const TaskConstMeta(
        debugName: "get_address",
        argNames: ["extendedPrivateKey", "addressIndex"],
      );

  @override
  Future<BigInt> crateBridgeGetChainIdValue({required ChainId chainId}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_chain_id(chainId, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 101, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_u_64,
        decodeErrorData: null,
      ),
      constMeta: kCrateBridgeGetChainIdValueConstMeta,
      argValues: [chainId],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateBridgeGetChainIdValueConstMeta => const TaskConstMeta(
        debugName: "get_chain_id_value",
        argNames: ["chainId"],
      );

  @override
  Future<String> crateBridgeGetChainName({required ChainId chainId}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_chain_id(chainId, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 102, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: null,
      ),
      constMeta: kCrateBridgeGetChainNameConstMeta,
      argValues: [chainId],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateBridgeGetChainNameConstMeta => const TaskConstMeta(
        debugName: "get_chain_name",
        argNames: ["chainId"],
      );

  @override
  Future<WalletResult> crateBridgeGetCoinInfo({required CoinType coinType}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_coin_type(coinType, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 103, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_wallet_result,
        decodeErrorData: null,
      ),
      constMeta: kCrateBridgeGetCoinInfoConstMeta,
      argValues: [coinType],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateBridgeGetCoinInfoConstMeta => const TaskConstMeta(
        debugName: "get_coin_info",
        argNames: ["coinType"],
      );

  @override
  Future<BigInt> crateBridgeGetEtherInWei() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 104, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_u_64,
        decodeErrorData: null,
      ),
      constMeta: kCrateBridgeGetEtherInWeiConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateBridgeGetEtherInWeiConstMeta => const TaskConstMeta(
        debugName: "get_ether_in_wei",
        argNames: [],
      );

  @override
  Future<String> crateBridgeGetEvmAddressFromPrivateKey(
      {required String privateKeyHex}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(privateKeyHex, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 105, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: sse_decode_String,
      ),
      constMeta: kCrateBridgeGetEvmAddressFromPrivateKeyConstMeta,
      argValues: [privateKeyHex],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateBridgeGetEvmAddressFromPrivateKeyConstMeta =>
      const TaskConstMeta(
        debugName: "get_evm_address_from_private_key",
        argNames: ["privateKeyHex"],
      );

  @override
  Future<BigInt> crateBridgeGetGweiInWei() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 106, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_u_64,
        decodeErrorData: null,
      ),
      constMeta: kCrateBridgeGetGweiInWeiConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateBridgeGetGweiInWeiConstMeta => const TaskConstMeta(
        debugName: "get_gwei_in_wei",
        argNames: [],
      );

  @override
  Future<String> crateBridgeGetPublicKey({required String extendedPrivateKey}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(extendedPrivateKey, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 107, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: sse_decode_String,
      ),
      constMeta: kCrateBridgeGetPublicKeyConstMeta,
      argValues: [extendedPrivateKey],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateBridgeGetPublicKeyConstMeta => const TaskConstMeta(
        debugName: "get_public_key",
        argNames: ["extendedPrivateKey"],
      );

  @override
  Future<WalletResult> crateBridgeGetPurposeInfo({required Purpose purpose}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_purpose(purpose, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 108, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_wallet_result,
        decodeErrorData: null,
      ),
      constMeta: kCrateBridgeGetPurposeInfoConstMeta,
      argValues: [purpose],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateBridgeGetPurposeInfoConstMeta => const TaskConstMeta(
        debugName: "get_purpose_info",
        argNames: ["purpose"],
      );

  @override
  Future<BigInt> crateBridgeGetTokenTransferGas() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 109, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_u_64,
        decodeErrorData: null,
      ),
      constMeta: kCrateBridgeGetTokenTransferGasConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateBridgeGetTokenTransferGasConstMeta =>
      const TaskConstMeta(
        debugName: "get_token_transfer_gas",
        argNames: [],
      );

  @override
  Future<BigInt> crateBridgeGetTransferGas() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 110, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_u_64,
        decodeErrorData: null,
      ),
      constMeta: kCrateBridgeGetTransferGasConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateBridgeGetTransferGasConstMeta => const TaskConstMeta(
        debugName: "get_transfer_gas",
        argNames: [],
      );

  @override
  Future<String> crateBridgeGweiToWei({required BigInt gwei}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_u_64(gwei, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 111, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: null,
      ),
      constMeta: kCrateBridgeGweiToWeiConstMeta,
      argValues: [gwei],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateBridgeGweiToWeiConstMeta => const TaskConstMeta(
        debugName: "gwei_to_wei",
        argNames: ["gwei"],
      );

  @override
  Future<String> crateBridgeHealthCheck() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 112, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: null,
      ),
      constMeta: kCrateBridgeHealthCheckConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateBridgeHealthCheckConstMeta => const TaskConstMeta(
        debugName: "health_check",
        argNames: [],
      );

  @override
  Future<bool> crateBridgeIsTestnetChain({required ChainId chainId}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_chain_id(chainId, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 113, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_bool,
        decodeErrorData: null,
      ),
      constMeta: kCrateBridgeIsTestnetChainConstMeta,
      argValues: [chainId],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateBridgeIsTestnetChainConstMeta => const TaskConstMeta(
        debugName: "is_testnet_chain",
        argNames: ["chainId"],
      );

  @override
  Future<String> crateBridgeMnemonicPhraseToSeedHex(
      {required String phrase, String? passphrase}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(phrase, serializer);
        sse_encode_opt_String(passphrase, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 114, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: sse_decode_String,
      ),
      constMeta: kCrateBridgeMnemonicPhraseToSeedHexConstMeta,
      argValues: [phrase, passphrase],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateBridgeMnemonicPhraseToSeedHexConstMeta =>
      const TaskConstMeta(
        debugName:
            "mnemonic_phrase_to_seed_hex(dart_style=mnemonicPhraseToSeedHex)",
        argNames: ["phrase", "passphrase"],
      );

  @override
  Future<WalletResult> crateBridgeParseBip44Path({required String path}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(path, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 115, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_wallet_result,
        decodeErrorData: sse_decode_String,
      ),
      constMeta: kCrateBridgeParseBip44PathConstMeta,
      argValues: [path],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateBridgeParseBip44PathConstMeta => const TaskConstMeta(
        debugName: "parse_bip44_path",
        argNames: ["path"],
      );

  @override
  Future<String> crateBridgeParseEvmAddress({required String address}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(address, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 116, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: sse_decode_String,
      ),
      constMeta: kCrateBridgeParseEvmAddressConstMeta,
      argValues: [address],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateBridgeParseEvmAddressConstMeta => const TaskConstMeta(
        debugName: "parse_evm_address",
        argNames: ["address"],
      );

  @override
  Future<String> crateBridgeRecoverSignerAddress(
      {required String hashHex, required String signatureHex}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(hashHex, serializer);
        sse_encode_String(signatureHex, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 117, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: sse_decode_String,
      ),
      constMeta: kCrateBridgeRecoverSignerAddressConstMeta,
      argValues: [hashHex, signatureHex],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateBridgeRecoverSignerAddressConstMeta =>
      const TaskConstMeta(
        debugName: "recover_signer_address",
        argNames: ["hashHex", "signatureHex"],
      );

  @override
  Future<String> crateBridgeSignEip1559Transaction(
      {required String privateKeyHex,
      required ChainId chainId,
      required BigInt nonce,
      required String to,
      required String valueWei,
      required BigInt gasLimit,
      required BigInt maxPriorityFeeGwei,
      required BigInt maxFeeGwei,
      String? dataHex}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(privateKeyHex, serializer);
        sse_encode_chain_id(chainId, serializer);
        sse_encode_u_64(nonce, serializer);
        sse_encode_String(to, serializer);
        sse_encode_String(valueWei, serializer);
        sse_encode_u_64(gasLimit, serializer);
        sse_encode_u_64(maxPriorityFeeGwei, serializer);
        sse_encode_u_64(maxFeeGwei, serializer);
        sse_encode_opt_String(dataHex, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 118, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: sse_decode_String,
      ),
      constMeta: kCrateBridgeSignEip1559TransactionConstMeta,
      argValues: [
        privateKeyHex,
        chainId,
        nonce,
        to,
        valueWei,
        gasLimit,
        maxPriorityFeeGwei,
        maxFeeGwei,
        dataHex
      ],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateBridgeSignEip1559TransactionConstMeta =>
      const TaskConstMeta(
        debugName: "sign_eip1559_transaction",
        argNames: [
          "privateKeyHex",
          "chainId",
          "nonce",
          "to",
          "valueWei",
          "gasLimit",
          "maxPriorityFeeGwei",
          "maxFeeGwei",
          "dataHex"
        ],
      );

  @override
  Future<Uint8List> crateBridgeSignedEvmTransactionEncode(
      {required SignedEvmTransaction that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_box_autoadd_signed_evm_transaction(that, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 119, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_list_prim_u_8_strict,
        decodeErrorData: sse_decode_String,
      ),
      constMeta: kCrateBridgeSignedEvmTransactionEncodeConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateBridgeSignedEvmTransactionEncodeConstMeta =>
      const TaskConstMeta(
        debugName: "signed_evm_transaction_encode",
        argNames: ["that"],
      );

  @override
  Future<SignedEvmTransaction> crateBridgeSignedEvmTransactionNew(
      {required Eip1559Transaction transaction,
      required EvmSignature signature}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_box_autoadd_eip_1559_transaction(transaction, serializer);
        sse_encode_box_autoadd_evm_signature(signature, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 120, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_signed_evm_transaction,
        decodeErrorData: null,
      ),
      constMeta: kCrateBridgeSignedEvmTransactionNewConstMeta,
      argValues: [transaction, signature],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateBridgeSignedEvmTransactionNewConstMeta =>
      const TaskConstMeta(
        debugName: "signed_evm_transaction_new",
        argNames: ["transaction", "signature"],
      );

  @override
  Future<String> crateBridgeSignedEvmTransactionToRawTransaction(
      {required SignedEvmTransaction that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_box_autoadd_signed_evm_transaction(that, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 121, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: sse_decode_String,
      ),
      constMeta: kCrateBridgeSignedEvmTransactionToRawTransactionConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateBridgeSignedEvmTransactionToRawTransactionConstMeta =>
      const TaskConstMeta(
        debugName: "signed_evm_transaction_to_raw_transaction",
        argNames: ["that"],
      );

  @override
  Future<Uint8List> crateBridgeSignedEvmTransactionTxHash(
      {required SignedEvmTransaction that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_box_autoadd_signed_evm_transaction(that, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 122, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_list_prim_u_8_strict,
        decodeErrorData: sse_decode_String,
      ),
      constMeta: kCrateBridgeSignedEvmTransactionTxHashConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateBridgeSignedEvmTransactionTxHashConstMeta =>
      const TaskConstMeta(
        debugName: "signed_evm_transaction_tx_hash",
        argNames: ["that"],
      );

  @override
  Future<String> crateBridgeSignedEvmTransactionTxHashHex(
      {required SignedEvmTransaction that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_box_autoadd_signed_evm_transaction(that, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 123, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: sse_decode_String,
      ),
      constMeta: kCrateBridgeSignedEvmTransactionTxHashHexConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateBridgeSignedEvmTransactionTxHashHexConstMeta =>
      const TaskConstMeta(
        debugName: "signed_evm_transaction_tx_hash_hex",
        argNames: ["that"],
      );

  @override
  Future<bool> crateBridgeValidateEvmAddressChecksum(
      {required String address}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(address, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 124, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_bool,
        decodeErrorData: null,
      ),
      constMeta: kCrateBridgeValidateEvmAddressChecksumConstMeta,
      argValues: [address],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateBridgeValidateEvmAddressChecksumConstMeta =>
      const TaskConstMeta(
        debugName: "validate_evm_address_checksum",
        argNames: ["address"],
      );

  @override
  Future<bool> crateBridgeValidateMnemonic({required String phrase}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(phrase, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 125, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_bool,
        decodeErrorData: null,
      ),
      constMeta: kCrateBridgeValidateMnemonicConstMeta,
      argValues: [phrase],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateBridgeValidateMnemonicConstMeta =>
      const TaskConstMeta(
        debugName: "validate_mnemonic",
        argNames: ["phrase"],
      );

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_Bip44Account => wire
          .rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBip44Account;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_Bip44Account => wire
          .rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBip44Account;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_Bip44Wallet => wire
          .rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBip44Wallet;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_Bip44Wallet => wire
          .rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBip44Wallet;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_EvmAddress => wire
          .rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerEvmAddress;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_EvmAddress => wire
          .rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerEvmAddress;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_EvmSigner => wire
          .rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerEvmSigner;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_EvmSigner => wire
          .rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerEvmSigner;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_ExtendedPrivateKey => wire
          .rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerExtendedPrivateKey;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_ExtendedPrivateKey => wire
          .rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerExtendedPrivateKey;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_ExtendedPublicKey => wire
          .rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerExtendedPublicKey;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_ExtendedPublicKey => wire
          .rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerExtendedPublicKey;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_Mnemonic => wire
          .rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMnemonic;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_Mnemonic => wire
          .rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMnemonic;

  @protected
  Bip44Account
      dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBip44Account(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return Bip44AccountImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  Bip44Wallet
      dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBip44Wallet(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return Bip44WalletImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  EvmAddress
      dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerEvmAddress(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return EvmAddressImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  EvmSigner
      dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerEvmSigner(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return EvmSignerImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  ExtendedPrivateKey
      dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerExtendedPrivateKey(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return ExtendedPrivateKeyImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  ExtendedPublicKey
      dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerExtendedPublicKey(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return ExtendedPublicKeyImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  Mnemonic
      dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMnemonic(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return MnemonicImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  Bip44Wallet
      dco_decode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBip44Wallet(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return Bip44WalletImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  Bip44Account
      dco_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBip44Account(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return Bip44AccountImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  Bip44Wallet
      dco_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBip44Wallet(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return Bip44WalletImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  EvmAddress
      dco_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerEvmAddress(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return EvmAddressImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  EvmSigner
      dco_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerEvmSigner(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return EvmSignerImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  ExtendedPrivateKey
      dco_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerExtendedPrivateKey(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return ExtendedPrivateKeyImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  ExtendedPublicKey
      dco_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerExtendedPublicKey(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return ExtendedPublicKeyImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  Mnemonic
      dco_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMnemonic(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return MnemonicImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  Bip44Account
      dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBip44Account(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return Bip44AccountImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  Bip44Wallet
      dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBip44Wallet(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return Bip44WalletImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  EvmAddress
      dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerEvmAddress(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return EvmAddressImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  EvmSigner
      dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerEvmSigner(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return EvmSignerImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  ExtendedPrivateKey
      dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerExtendedPrivateKey(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return ExtendedPrivateKeyImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  ExtendedPublicKey
      dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerExtendedPublicKey(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return ExtendedPublicKeyImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  Mnemonic
      dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMnemonic(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return MnemonicImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  String dco_decode_String(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as String;
  }

  @protected
  bool dco_decode_bool(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as bool;
  }

  @protected
  ChainId dco_decode_box_autoadd_chain_id(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_chain_id(raw);
  }

  @protected
  Eip1559Transaction dco_decode_box_autoadd_eip_1559_transaction(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_eip_1559_transaction(raw);
  }

  @protected
  Eip1559TransactionBuilder dco_decode_box_autoadd_eip_1559_transaction_builder(
      dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_eip_1559_transaction_builder(raw);
  }

  @protected
  EvmSignature dco_decode_box_autoadd_evm_signature(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_evm_signature(raw);
  }

  @protected
  EvmWei dco_decode_box_autoadd_evm_wei(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_evm_wei(raw);
  }

  @protected
  SignedEvmTransaction dco_decode_box_autoadd_signed_evm_transaction(
      dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_signed_evm_transaction(raw);
  }

  @protected
  BigInt dco_decode_box_autoadd_u_64(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_u_64(raw);
  }

  @protected
  Chain dco_decode_chain(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return Chain.values[raw as int];
  }

  @protected
  ChainId dco_decode_chain_id(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return ChainId.values[raw as int];
  }

  @protected
  CoinType dco_decode_coin_type(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return CoinType.values[raw as int];
  }

  @protected
  Eip1559Transaction dco_decode_eip_1559_transaction(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 8)
      throw Exception('unexpected arr length: expect 8 but see ${arr.length}');
    return Eip1559Transaction(
      chainId: dco_decode_chain_id(arr[0]),
      nonce: dco_decode_u_64(arr[1]),
      maxPriorityFeePerGas: dco_decode_String(arr[2]),
      maxFeePerGas: dco_decode_String(arr[3]),
      gasLimit: dco_decode_u_64(arr[4]),
      to: dco_decode_opt_String(arr[5]),
      value: dco_decode_String(arr[6]),
      dataHex: dco_decode_String(arr[7]),
    );
  }

  @protected
  Eip1559TransactionBuilder dco_decode_eip_1559_transaction_builder(
      dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 8)
      throw Exception('unexpected arr length: expect 8 but see ${arr.length}');
    return Eip1559TransactionBuilder(
      chainId: dco_decode_opt_box_autoadd_chain_id(arr[0]),
      nonce: dco_decode_opt_box_autoadd_u_64(arr[1]),
      maxPriorityFeePerGas: dco_decode_opt_String(arr[2]),
      maxFeePerGas: dco_decode_opt_String(arr[3]),
      gasLimit: dco_decode_opt_box_autoadd_u_64(arr[4]),
      to: dco_decode_opt_String(arr[5]),
      value: dco_decode_opt_String(arr[6]),
      dataHex: dco_decode_opt_String(arr[7]),
    );
  }

  @protected
  EvmAccessListItem dco_decode_evm_access_list_item(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2)
      throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return EvmAccessListItem(
      address: dco_decode_String(arr[0]),
      storageKeys: dco_decode_list_String(arr[1]),
    );
  }

  @protected
  EvmSignature dco_decode_evm_signature(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 3)
      throw Exception('unexpected arr length: expect 3 but see ${arr.length}');
    return EvmSignature(
      rHex: dco_decode_String(arr[0]),
      sHex: dco_decode_String(arr[1]),
      v: dco_decode_u_8(arr[2]),
    );
  }

  @protected
  EvmWei dco_decode_evm_wei(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 1)
      throw Exception('unexpected arr length: expect 1 but see ${arr.length}');
    return EvmWei(
      valueHex: dco_decode_String(arr[0]),
    );
  }

  @protected
  int dco_decode_i_32(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as int;
  }

  @protected
  List<String> dco_decode_list_String(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_String).toList();
  }

  @protected
  List<int> dco_decode_list_prim_u_8_loose(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as List<int>;
  }

  @protected
  Uint8List dco_decode_list_prim_u_8_strict(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as Uint8List;
  }

  @protected
  Network dco_decode_network(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return Network.values[raw as int];
  }

  @protected
  String? dco_decode_opt_String(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_String(raw);
  }

  @protected
  ChainId? dco_decode_opt_box_autoadd_chain_id(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_chain_id(raw);
  }

  @protected
  BigInt? dco_decode_opt_box_autoadd_u_64(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_u_64(raw);
  }

  @protected
  Purpose dco_decode_purpose(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return Purpose.values[raw as int];
  }

  @protected
  SignedEvmTransaction dco_decode_signed_evm_transaction(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2)
      throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return SignedEvmTransaction(
      transaction: dco_decode_eip_1559_transaction(arr[0]),
      signature: dco_decode_evm_signature(arr[1]),
    );
  }

  @protected
  int dco_decode_u_32(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as int;
  }

  @protected
  BigInt dco_decode_u_64(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dcoDecodeU64(raw);
  }

  @protected
  int dco_decode_u_8(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as int;
  }

  @protected
  void dco_decode_unit(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return;
  }

  @protected
  BigInt dco_decode_usize(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dcoDecodeU64(raw);
  }

  @protected
  WalletResult dco_decode_wallet_result(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 3)
      throw Exception('unexpected arr length: expect 3 but see ${arr.length}');
    return WalletResult(
      success: dco_decode_bool(arr[0]),
      message: dco_decode_String(arr[1]),
      data: dco_decode_opt_String(arr[2]),
    );
  }

  @protected
  Bip44Account
      sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBip44Account(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return Bip44AccountImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  Bip44Wallet
      sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBip44Wallet(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return Bip44WalletImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  EvmAddress
      sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerEvmAddress(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return EvmAddressImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  EvmSigner
      sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerEvmSigner(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return EvmSignerImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  ExtendedPrivateKey
      sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerExtendedPrivateKey(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return ExtendedPrivateKeyImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  ExtendedPublicKey
      sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerExtendedPublicKey(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return ExtendedPublicKeyImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  Mnemonic
      sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMnemonic(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return MnemonicImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  Bip44Wallet
      sse_decode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBip44Wallet(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return Bip44WalletImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  Bip44Account
      sse_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBip44Account(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return Bip44AccountImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  Bip44Wallet
      sse_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBip44Wallet(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return Bip44WalletImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  EvmAddress
      sse_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerEvmAddress(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return EvmAddressImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  EvmSigner
      sse_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerEvmSigner(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return EvmSignerImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  ExtendedPrivateKey
      sse_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerExtendedPrivateKey(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return ExtendedPrivateKeyImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  ExtendedPublicKey
      sse_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerExtendedPublicKey(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return ExtendedPublicKeyImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  Mnemonic
      sse_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMnemonic(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return MnemonicImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  Bip44Account
      sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBip44Account(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return Bip44AccountImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  Bip44Wallet
      sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBip44Wallet(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return Bip44WalletImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  EvmAddress
      sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerEvmAddress(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return EvmAddressImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  EvmSigner
      sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerEvmSigner(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return EvmSignerImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  ExtendedPrivateKey
      sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerExtendedPrivateKey(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return ExtendedPrivateKeyImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  ExtendedPublicKey
      sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerExtendedPublicKey(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return ExtendedPublicKeyImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  Mnemonic
      sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMnemonic(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return MnemonicImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  String sse_decode_String(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_list_prim_u_8_strict(deserializer);
    return utf8.decoder.convert(inner);
  }

  @protected
  bool sse_decode_bool(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getUint8() != 0;
  }

  @protected
  ChainId sse_decode_box_autoadd_chain_id(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_chain_id(deserializer));
  }

  @protected
  Eip1559Transaction sse_decode_box_autoadd_eip_1559_transaction(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_eip_1559_transaction(deserializer));
  }

  @protected
  Eip1559TransactionBuilder sse_decode_box_autoadd_eip_1559_transaction_builder(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_eip_1559_transaction_builder(deserializer));
  }

  @protected
  EvmSignature sse_decode_box_autoadd_evm_signature(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_evm_signature(deserializer));
  }

  @protected
  EvmWei sse_decode_box_autoadd_evm_wei(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_evm_wei(deserializer));
  }

  @protected
  SignedEvmTransaction sse_decode_box_autoadd_signed_evm_transaction(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_signed_evm_transaction(deserializer));
  }

  @protected
  BigInt sse_decode_box_autoadd_u_64(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_u_64(deserializer));
  }

  @protected
  Chain sse_decode_chain(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_i_32(deserializer);
    return Chain.values[inner];
  }

  @protected
  ChainId sse_decode_chain_id(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_i_32(deserializer);
    return ChainId.values[inner];
  }

  @protected
  CoinType sse_decode_coin_type(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_i_32(deserializer);
    return CoinType.values[inner];
  }

  @protected
  Eip1559Transaction sse_decode_eip_1559_transaction(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_chainId = sse_decode_chain_id(deserializer);
    var var_nonce = sse_decode_u_64(deserializer);
    var var_maxPriorityFeePerGas = sse_decode_String(deserializer);
    var var_maxFeePerGas = sse_decode_String(deserializer);
    var var_gasLimit = sse_decode_u_64(deserializer);
    var var_to = sse_decode_opt_String(deserializer);
    var var_value = sse_decode_String(deserializer);
    var var_dataHex = sse_decode_String(deserializer);
    return Eip1559Transaction(
        chainId: var_chainId,
        nonce: var_nonce,
        maxPriorityFeePerGas: var_maxPriorityFeePerGas,
        maxFeePerGas: var_maxFeePerGas,
        gasLimit: var_gasLimit,
        to: var_to,
        value: var_value,
        dataHex: var_dataHex);
  }

  @protected
  Eip1559TransactionBuilder sse_decode_eip_1559_transaction_builder(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_chainId = sse_decode_opt_box_autoadd_chain_id(deserializer);
    var var_nonce = sse_decode_opt_box_autoadd_u_64(deserializer);
    var var_maxPriorityFeePerGas = sse_decode_opt_String(deserializer);
    var var_maxFeePerGas = sse_decode_opt_String(deserializer);
    var var_gasLimit = sse_decode_opt_box_autoadd_u_64(deserializer);
    var var_to = sse_decode_opt_String(deserializer);
    var var_value = sse_decode_opt_String(deserializer);
    var var_dataHex = sse_decode_opt_String(deserializer);
    return Eip1559TransactionBuilder(
        chainId: var_chainId,
        nonce: var_nonce,
        maxPriorityFeePerGas: var_maxPriorityFeePerGas,
        maxFeePerGas: var_maxFeePerGas,
        gasLimit: var_gasLimit,
        to: var_to,
        value: var_value,
        dataHex: var_dataHex);
  }

  @protected
  EvmAccessListItem sse_decode_evm_access_list_item(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_address = sse_decode_String(deserializer);
    var var_storageKeys = sse_decode_list_String(deserializer);
    return EvmAccessListItem(
        address: var_address, storageKeys: var_storageKeys);
  }

  @protected
  EvmSignature sse_decode_evm_signature(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_rHex = sse_decode_String(deserializer);
    var var_sHex = sse_decode_String(deserializer);
    var var_v = sse_decode_u_8(deserializer);
    return EvmSignature(rHex: var_rHex, sHex: var_sHex, v: var_v);
  }

  @protected
  EvmWei sse_decode_evm_wei(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_valueHex = sse_decode_String(deserializer);
    return EvmWei(valueHex: var_valueHex);
  }

  @protected
  int sse_decode_i_32(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getInt32();
  }

  @protected
  List<String> sse_decode_list_String(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <String>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_String(deserializer));
    }
    return ans_;
  }

  @protected
  List<int> sse_decode_list_prim_u_8_loose(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var len_ = sse_decode_i_32(deserializer);
    return deserializer.buffer.getUint8List(len_);
  }

  @protected
  Uint8List sse_decode_list_prim_u_8_strict(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var len_ = sse_decode_i_32(deserializer);
    return deserializer.buffer.getUint8List(len_);
  }

  @protected
  Network sse_decode_network(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_i_32(deserializer);
    return Network.values[inner];
  }

  @protected
  String? sse_decode_opt_String(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_String(deserializer));
    } else {
      return null;
    }
  }

  @protected
  ChainId? sse_decode_opt_box_autoadd_chain_id(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_chain_id(deserializer));
    } else {
      return null;
    }
  }

  @protected
  BigInt? sse_decode_opt_box_autoadd_u_64(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_u_64(deserializer));
    } else {
      return null;
    }
  }

  @protected
  Purpose sse_decode_purpose(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_i_32(deserializer);
    return Purpose.values[inner];
  }

  @protected
  SignedEvmTransaction sse_decode_signed_evm_transaction(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_transaction = sse_decode_eip_1559_transaction(deserializer);
    var var_signature = sse_decode_evm_signature(deserializer);
    return SignedEvmTransaction(
        transaction: var_transaction, signature: var_signature);
  }

  @protected
  int sse_decode_u_32(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getUint32();
  }

  @protected
  BigInt sse_decode_u_64(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getBigUint64();
  }

  @protected
  int sse_decode_u_8(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getUint8();
  }

  @protected
  void sse_decode_unit(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
  }

  @protected
  BigInt sse_decode_usize(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getBigUint64();
  }

  @protected
  WalletResult sse_decode_wallet_result(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_success = sse_decode_bool(deserializer);
    var var_message = sse_decode_String(deserializer);
    var var_data = sse_decode_opt_String(deserializer);
    return WalletResult(
        success: var_success, message: var_message, data: var_data);
  }

  @protected
  void
      sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBip44Account(
          Bip44Account self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as Bip44AccountImpl).frbInternalSseEncode(move: true),
        serializer);
  }

  @protected
  void
      sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBip44Wallet(
          Bip44Wallet self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as Bip44WalletImpl).frbInternalSseEncode(move: true), serializer);
  }

  @protected
  void
      sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerEvmAddress(
          EvmAddress self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as EvmAddressImpl).frbInternalSseEncode(move: true), serializer);
  }

  @protected
  void
      sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerEvmSigner(
          EvmSigner self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as EvmSignerImpl).frbInternalSseEncode(move: true), serializer);
  }

  @protected
  void
      sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerExtendedPrivateKey(
          ExtendedPrivateKey self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as ExtendedPrivateKeyImpl).frbInternalSseEncode(move: true),
        serializer);
  }

  @protected
  void
      sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerExtendedPublicKey(
          ExtendedPublicKey self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as ExtendedPublicKeyImpl).frbInternalSseEncode(move: true),
        serializer);
  }

  @protected
  void
      sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMnemonic(
          Mnemonic self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as MnemonicImpl).frbInternalSseEncode(move: true), serializer);
  }

  @protected
  void
      sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBip44Wallet(
          Bip44Wallet self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as Bip44WalletImpl).frbInternalSseEncode(move: false),
        serializer);
  }

  @protected
  void
      sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBip44Account(
          Bip44Account self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as Bip44AccountImpl).frbInternalSseEncode(move: false),
        serializer);
  }

  @protected
  void
      sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBip44Wallet(
          Bip44Wallet self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as Bip44WalletImpl).frbInternalSseEncode(move: false),
        serializer);
  }

  @protected
  void
      sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerEvmAddress(
          EvmAddress self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as EvmAddressImpl).frbInternalSseEncode(move: false), serializer);
  }

  @protected
  void
      sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerEvmSigner(
          EvmSigner self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as EvmSignerImpl).frbInternalSseEncode(move: false), serializer);
  }

  @protected
  void
      sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerExtendedPrivateKey(
          ExtendedPrivateKey self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as ExtendedPrivateKeyImpl).frbInternalSseEncode(move: false),
        serializer);
  }

  @protected
  void
      sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerExtendedPublicKey(
          ExtendedPublicKey self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as ExtendedPublicKeyImpl).frbInternalSseEncode(move: false),
        serializer);
  }

  @protected
  void
      sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMnemonic(
          Mnemonic self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as MnemonicImpl).frbInternalSseEncode(move: false), serializer);
  }

  @protected
  void
      sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBip44Account(
          Bip44Account self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as Bip44AccountImpl).frbInternalSseEncode(move: null),
        serializer);
  }

  @protected
  void
      sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBip44Wallet(
          Bip44Wallet self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as Bip44WalletImpl).frbInternalSseEncode(move: null), serializer);
  }

  @protected
  void
      sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerEvmAddress(
          EvmAddress self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as EvmAddressImpl).frbInternalSseEncode(move: null), serializer);
  }

  @protected
  void
      sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerEvmSigner(
          EvmSigner self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as EvmSignerImpl).frbInternalSseEncode(move: null), serializer);
  }

  @protected
  void
      sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerExtendedPrivateKey(
          ExtendedPrivateKey self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as ExtendedPrivateKeyImpl).frbInternalSseEncode(move: null),
        serializer);
  }

  @protected
  void
      sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerExtendedPublicKey(
          ExtendedPublicKey self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as ExtendedPublicKeyImpl).frbInternalSseEncode(move: null),
        serializer);
  }

  @protected
  void
      sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMnemonic(
          Mnemonic self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as MnemonicImpl).frbInternalSseEncode(move: null), serializer);
  }

  @protected
  void sse_encode_String(String self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_prim_u_8_strict(utf8.encoder.convert(self), serializer);
  }

  @protected
  void sse_encode_bool(bool self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putUint8(self ? 1 : 0);
  }

  @protected
  void sse_encode_box_autoadd_chain_id(ChainId self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_chain_id(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_eip_1559_transaction(
      Eip1559Transaction self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_eip_1559_transaction(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_eip_1559_transaction_builder(
      Eip1559TransactionBuilder self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_eip_1559_transaction_builder(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_evm_signature(
      EvmSignature self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_evm_signature(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_evm_wei(EvmWei self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_evm_wei(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_signed_evm_transaction(
      SignedEvmTransaction self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_signed_evm_transaction(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_u_64(BigInt self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_u_64(self, serializer);
  }

  @protected
  void sse_encode_chain(Chain self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.index, serializer);
  }

  @protected
  void sse_encode_chain_id(ChainId self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.index, serializer);
  }

  @protected
  void sse_encode_coin_type(CoinType self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.index, serializer);
  }

  @protected
  void sse_encode_eip_1559_transaction(
      Eip1559Transaction self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_chain_id(self.chainId, serializer);
    sse_encode_u_64(self.nonce, serializer);
    sse_encode_String(self.maxPriorityFeePerGas, serializer);
    sse_encode_String(self.maxFeePerGas, serializer);
    sse_encode_u_64(self.gasLimit, serializer);
    sse_encode_opt_String(self.to, serializer);
    sse_encode_String(self.value, serializer);
    sse_encode_String(self.dataHex, serializer);
  }

  @protected
  void sse_encode_eip_1559_transaction_builder(
      Eip1559TransactionBuilder self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_opt_box_autoadd_chain_id(self.chainId, serializer);
    sse_encode_opt_box_autoadd_u_64(self.nonce, serializer);
    sse_encode_opt_String(self.maxPriorityFeePerGas, serializer);
    sse_encode_opt_String(self.maxFeePerGas, serializer);
    sse_encode_opt_box_autoadd_u_64(self.gasLimit, serializer);
    sse_encode_opt_String(self.to, serializer);
    sse_encode_opt_String(self.value, serializer);
    sse_encode_opt_String(self.dataHex, serializer);
  }

  @protected
  void sse_encode_evm_access_list_item(
      EvmAccessListItem self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.address, serializer);
    sse_encode_list_String(self.storageKeys, serializer);
  }

  @protected
  void sse_encode_evm_signature(EvmSignature self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.rHex, serializer);
    sse_encode_String(self.sHex, serializer);
    sse_encode_u_8(self.v, serializer);
  }

  @protected
  void sse_encode_evm_wei(EvmWei self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.valueHex, serializer);
  }

  @protected
  void sse_encode_i_32(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putInt32(self);
  }

  @protected
  void sse_encode_list_String(List<String> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_String(item, serializer);
    }
  }

  @protected
  void sse_encode_list_prim_u_8_loose(
      List<int> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    serializer.buffer
        .putUint8List(self is Uint8List ? self : Uint8List.fromList(self));
  }

  @protected
  void sse_encode_list_prim_u_8_strict(
      Uint8List self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    serializer.buffer.putUint8List(self);
  }

  @protected
  void sse_encode_network(Network self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.index, serializer);
  }

  @protected
  void sse_encode_opt_String(String? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_String(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_chain_id(
      ChainId? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_chain_id(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_u_64(BigInt? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_u_64(self, serializer);
    }
  }

  @protected
  void sse_encode_purpose(Purpose self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.index, serializer);
  }

  @protected
  void sse_encode_signed_evm_transaction(
      SignedEvmTransaction self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_eip_1559_transaction(self.transaction, serializer);
    sse_encode_evm_signature(self.signature, serializer);
  }

  @protected
  void sse_encode_u_32(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putUint32(self);
  }

  @protected
  void sse_encode_u_64(BigInt self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putBigUint64(self);
  }

  @protected
  void sse_encode_u_8(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putUint8(self);
  }

  @protected
  void sse_encode_unit(void self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
  }

  @protected
  void sse_encode_usize(BigInt self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putBigUint64(self);
  }

  @protected
  void sse_encode_wallet_result(WalletResult self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_bool(self.success, serializer);
    sse_encode_String(self.message, serializer);
    sse_encode_opt_String(self.data, serializer);
  }
}

@sealed
class Bip44AccountImpl extends RustOpaque implements Bip44Account {
  // Not to be used by end users
  Bip44AccountImpl.frbInternalDcoDecode(List<dynamic> wire)
      : super.frbInternalDcoDecode(wire, _kStaticData);

  // Not to be used by end users
  Bip44AccountImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative)
      : super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount:
        RustLib.instance.api.rust_arc_increment_strong_count_Bip44Account,
    rustArcDecrementStrongCount:
        RustLib.instance.api.rust_arc_decrement_strong_count_Bip44Account,
    rustArcDecrementStrongCountPtr:
        RustLib.instance.api.rust_arc_decrement_strong_count_Bip44AccountPtr,
  );

  /// Get the account index
  Future<int> accountIndex() =>
      RustLib.instance.api.crateBridgeBip44AccountAccountIndex(
        that: this,
      );

  /// Get the coin type for this account
  Future<CoinType> coinType() =>
      RustLib.instance.api.crateBridgeBip44AccountCoinType(
        that: this,
      );

  /// Derive an address for the specified chain and index
  Future<String> deriveAddress({required Chain chain, required int index}) =>
      RustLib.instance.api.crateBridgeBip44AccountDeriveAddress(
          that: this, chain: chain, index: index);

  /// Derive a range of addresses
  Future<List<String>> deriveAddressRange(
          {required Chain chain, required int start, required int count}) =>
      RustLib.instance.api.crateBridgeBip44AccountDeriveAddressRange(
          that: this, chain: chain, start: start, count: count);

  /// Derive an external (receiving) address at the given index
  Future<String> deriveExternal({required int index}) => RustLib.instance.api
      .crateBridgeBip44AccountDeriveExternal(that: this, index: index);

  /// Derive an internal (change) address at the given index
  Future<String> deriveInternal({required int index}) => RustLib.instance.api
      .crateBridgeBip44AccountDeriveInternal(that: this, index: index);

  /// Get the extended key as a string (xprv format)
  Future<String> extendedKeyString() =>
      RustLib.instance.api.crateBridgeBip44AccountExtendedKeyString(
        that: this,
      );

  /// Get the network for this account
  Future<Network> network() =>
      RustLib.instance.api.crateBridgeBip44AccountNetwork(
        that: this,
      );

  /// Get the purpose (BIP standard) for this account
  Future<Purpose> purpose() =>
      RustLib.instance.api.crateBridgeBip44AccountPurpose(
        that: this,
      );
}

@sealed
class Bip44WalletImpl extends RustOpaque implements Bip44Wallet {
  // Not to be used by end users
  Bip44WalletImpl.frbInternalDcoDecode(List<dynamic> wire)
      : super.frbInternalDcoDecode(wire, _kStaticData);

  // Not to be used by end users
  Bip44WalletImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative)
      : super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount:
        RustLib.instance.api.rust_arc_increment_strong_count_Bip44Wallet,
    rustArcDecrementStrongCount:
        RustLib.instance.api.rust_arc_decrement_strong_count_Bip44Wallet,
    rustArcDecrementStrongCountPtr:
        RustLib.instance.api.rust_arc_decrement_strong_count_Bip44WalletPtr,
  );

  /// Get an account for a specific coin type
  Future<Bip44Account> getAccount(
          {required Purpose purpose,
          required CoinType coinType,
          required int accountIndex}) =>
      RustLib.instance.api.crateBridgeBip44WalletGetAccount(
          that: this,
          purpose: purpose,
          coinType: coinType,
          accountIndex: accountIndex);

  /// Get the network this wallet operates on
  Future<Network> network() =>
      RustLib.instance.api.crateBridgeBip44WalletNetwork(
        that: this,
      );
}

@sealed
class EvmAddressImpl extends RustOpaque implements EvmAddress {
  // Not to be used by end users
  EvmAddressImpl.frbInternalDcoDecode(List<dynamic> wire)
      : super.frbInternalDcoDecode(wire, _kStaticData);

  // Not to be used by end users
  EvmAddressImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative)
      : super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount:
        RustLib.instance.api.rust_arc_increment_strong_count_EvmAddress,
    rustArcDecrementStrongCount:
        RustLib.instance.api.rust_arc_decrement_strong_count_EvmAddress,
    rustArcDecrementStrongCountPtr:
        RustLib.instance.api.rust_arc_decrement_strong_count_EvmAddressPtr,
  );

  /// Check if this is the zero address
  Future<bool> isZero() => RustLib.instance.api.crateBridgeEvmAddressIsZero(
        that: this,
      );

  /// Returns the address as a byte array (20 bytes)
  Future<Uint8List> toBytes() =>
      RustLib.instance.api.crateBridgeEvmAddressToBytes(
        that: this,
      );

  /// Returns the EIP-55 checksummed hex string (with 0x prefix)
  Future<String> toChecksumString() =>
      RustLib.instance.api.crateBridgeEvmAddressToChecksumString(
        that: this,
      );

  /// Returns the lowercase hex string (with 0x prefix)
  Future<String> toHexString() =>
      RustLib.instance.api.crateBridgeEvmAddressToHexString(
        that: this,
      );
}

@sealed
class EvmSignerImpl extends RustOpaque implements EvmSigner {
  // Not to be used by end users
  EvmSignerImpl.frbInternalDcoDecode(List<dynamic> wire)
      : super.frbInternalDcoDecode(wire, _kStaticData);

  // Not to be used by end users
  EvmSignerImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative)
      : super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount:
        RustLib.instance.api.rust_arc_increment_strong_count_EvmSigner,
    rustArcDecrementStrongCount:
        RustLib.instance.api.rust_arc_decrement_strong_count_EvmSigner,
    rustArcDecrementStrongCountPtr:
        RustLib.instance.api.rust_arc_decrement_strong_count_EvmSignerPtr,
  );

  /// Returns the EVM address associated with this signer
  Future<EvmAddress> address() =>
      RustLib.instance.api.crateBridgeEvmSignerAddress(
        that: this,
      );

  /// Returns the EVM address as a checksummed hex string
  Future<String> addressString() =>
      RustLib.instance.api.crateBridgeEvmSignerAddressString(
        that: this,
      );

  /// Sign a transaction and return the signed transaction
  Future<SignedEvmTransaction> signAndBuild({required Eip1559Transaction tx}) =>
      RustLib.instance.api.crateBridgeEvmSignerSignAndBuild(that: this, tx: tx);

  /// Sign a message hash (32 bytes)
  Future<EvmSignature> signHash({required List<int> hash}) =>
      RustLib.instance.api.crateBridgeEvmSignerSignHash(that: this, hash: hash);

  /// Sign an EIP-1559 transaction
  Future<EvmSignature> signTransaction({required Eip1559Transaction tx}) =>
      RustLib.instance.api
          .crateBridgeEvmSignerSignTransaction(that: this, tx: tx);
}

@sealed
class ExtendedPrivateKeyImpl extends RustOpaque implements ExtendedPrivateKey {
  // Not to be used by end users
  ExtendedPrivateKeyImpl.frbInternalDcoDecode(List<dynamic> wire)
      : super.frbInternalDcoDecode(wire, _kStaticData);

  // Not to be used by end users
  ExtendedPrivateKeyImpl.frbInternalSseDecode(
      BigInt ptr, int externalSizeOnNative)
      : super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount:
        RustLib.instance.api.rust_arc_increment_strong_count_ExtendedPrivateKey,
    rustArcDecrementStrongCount:
        RustLib.instance.api.rust_arc_decrement_strong_count_ExtendedPrivateKey,
    rustArcDecrementStrongCountPtr: RustLib
        .instance.api.rust_arc_decrement_strong_count_ExtendedPrivateKeyPtr,
  );

  /// Get the child number index
  Future<int> childNumberIndex() =>
      RustLib.instance.api.crateBridgeExtendedPrivateKeyChildNumberIndex(
        that: this,
      );

  /// Get the depth in derivation tree (0 = master, 1 = level-1 child, etc.)
  Future<int> depth() =>
      RustLib.instance.api.crateBridgeExtendedPrivateKeyDepth(
        that: this,
      );

  /// Derive a single child key
  Future<ExtendedPrivateKey> deriveChild(
          {required int index, required bool hardened}) =>
      RustLib.instance.api.crateBridgeExtendedPrivateKeyDeriveChild(
          that: this, index: index, hardened: hardened);

  /// Derive using a path string (e.g., "m/44'/0'/0'/0/0")
  Future<ExtendedPrivateKey> derivePath({required String path}) =>
      RustLib.instance.api
          .crateBridgeExtendedPrivateKeyDerivePath(that: this, path: path);

  /// Get this key's fingerprint (4 bytes)
  Future<Uint8List> fingerprint() =>
      RustLib.instance.api.crateBridgeExtendedPrivateKeyFingerprint(
        that: this,
      );

  /// Check if this is a hardened key
  Future<bool> isHardened() =>
      RustLib.instance.api.crateBridgeExtendedPrivateKeyIsHardened(
        that: this,
      );

  /// Get the network this key belongs to
  Future<Network> network() =>
      RustLib.instance.api.crateBridgeExtendedPrivateKeyNetwork(
        that: this,
      );

  /// Get the parent fingerprint (4 bytes)
  Future<Uint8List> parentFingerprint() =>
      RustLib.instance.api.crateBridgeExtendedPrivateKeyParentFingerprint(
        that: this,
      );

  /// Convert to extended public key
  Future<ExtendedPublicKey> toExtendedPublicKey() =>
      RustLib.instance.api.crateBridgeExtendedPrivateKeyToExtendedPublicKey(
        that: this,
      );

  /// Serialize to extended key string (xprv... format)
  Future<String> toExtendedString() =>
      RustLib.instance.api.crateBridgeExtendedPrivateKeyToExtendedString(
        that: this,
      );
}

@sealed
class ExtendedPublicKeyImpl extends RustOpaque implements ExtendedPublicKey {
  // Not to be used by end users
  ExtendedPublicKeyImpl.frbInternalDcoDecode(List<dynamic> wire)
      : super.frbInternalDcoDecode(wire, _kStaticData);

  // Not to be used by end users
  ExtendedPublicKeyImpl.frbInternalSseDecode(
      BigInt ptr, int externalSizeOnNative)
      : super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount:
        RustLib.instance.api.rust_arc_increment_strong_count_ExtendedPublicKey,
    rustArcDecrementStrongCount:
        RustLib.instance.api.rust_arc_decrement_strong_count_ExtendedPublicKey,
    rustArcDecrementStrongCountPtr: RustLib
        .instance.api.rust_arc_decrement_strong_count_ExtendedPublicKeyPtr,
  );

  /// Get the child number index
  Future<int> childNumberIndex() =>
      RustLib.instance.api.crateBridgeExtendedPublicKeyChildNumberIndex(
        that: this,
      );

  /// Get the depth in derivation tree
  Future<int> depth() => RustLib.instance.api.crateBridgeExtendedPublicKeyDepth(
        that: this,
      );

  /// Derive a child public key (non-hardened only)
  Future<ExtendedPublicKey> deriveChild({required int index}) =>
      RustLib.instance.api
          .crateBridgeExtendedPublicKeyDeriveChild(that: this, index: index);

  /// Derive using a path string (only non-hardened paths allowed)
  Future<ExtendedPublicKey> derivePath({required String path}) =>
      RustLib.instance.api
          .crateBridgeExtendedPublicKeyDerivePath(that: this, path: path);

  /// Get this key's fingerprint (4 bytes)
  Future<Uint8List> fingerprint() =>
      RustLib.instance.api.crateBridgeExtendedPublicKeyFingerprint(
        that: this,
      );

  /// Check if this is a hardened key (public keys can only have non-hardened children)
  Future<bool> isHardened() =>
      RustLib.instance.api.crateBridgeExtendedPublicKeyIsHardened(
        that: this,
      );

  /// Get the network this key belongs to
  Future<Network> network() =>
      RustLib.instance.api.crateBridgeExtendedPublicKeyNetwork(
        that: this,
      );

  /// Get the parent fingerprint (4 bytes)
  Future<Uint8List> parentFingerprint() =>
      RustLib.instance.api.crateBridgeExtendedPublicKeyParentFingerprint(
        that: this,
      );

  /// Serialize to extended key string (xpub... format)
  Future<String> toExtendedString() =>
      RustLib.instance.api.crateBridgeExtendedPublicKeyToExtendedString(
        that: this,
      );
}

@sealed
class MnemonicImpl extends RustOpaque implements Mnemonic {
  // Not to be used by end users
  MnemonicImpl.frbInternalDcoDecode(List<dynamic> wire)
      : super.frbInternalDcoDecode(wire, _kStaticData);

  // Not to be used by end users
  MnemonicImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative)
      : super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount:
        RustLib.instance.api.rust_arc_increment_strong_count_Mnemonic,
    rustArcDecrementStrongCount:
        RustLib.instance.api.rust_arc_decrement_strong_count_Mnemonic,
    rustArcDecrementStrongCountPtr:
        RustLib.instance.api.rust_arc_decrement_strong_count_MnemonicPtr,
  );

  /// Validate that this mnemonic is valid (always true for constructed mnemonics)
  Future<bool> isValid() => RustLib.instance.api.crateBridgeMnemonicIsValid(
        that: this,
      );

  /// Convert mnemonic to string phrase
  Future<String> toPhrase() => RustLib.instance.api.crateBridgeMnemonicToPhrase(
        that: this,
      );

  /// Convert mnemonic to BIP39 seed bytes (64 bytes)
  Future<Uint8List> toSeed({String? passphrase}) => RustLib.instance.api
      .crateBridgeMnemonicToSeed(that: this, passphrase: passphrase);

  /// Get the word count
  Future<int> wordCount() => RustLib.instance.api.crateBridgeMnemonicWordCount(
        that: this,
      );
}
